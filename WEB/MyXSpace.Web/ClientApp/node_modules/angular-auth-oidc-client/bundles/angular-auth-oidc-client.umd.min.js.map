{"version":3,"sources":["ng://angular-auth-oidc-client/lib/models/jwtkeys.ts","ng://angular-auth-oidc-client/lib/models/authorization-result.ts","ng://angular-auth-oidc-client/lib/models/authorization-state.enum.ts","ng://angular-auth-oidc-client/lib/models/validation-result.enum.ts","ng://angular-auth-oidc-client/lib/models/validate-state-result.model.ts","ng://angular-auth-oidc-client/lib/data-services/oidc-data.service.ts","node_modules/tslib/tslib.es6.js","ng://angular-auth-oidc-client/lib/services/platform.provider.ts","ng://angular-auth-oidc-client/lib/services/auth-configuration.provider.ts","ng://angular-auth-oidc-client/lib/services/oidc.logger.service.ts","ng://angular-auth-oidc-client/lib/services/existing-iframe.service.ts","ng://angular-auth-oidc-client/lib/services/oidc-equality-helper.service.ts","ng://angular-auth-oidc-client/lib/services/oidc-token-helper.service.ts","ng://angular-auth-oidc-client/lib/services/oidc.security.storage.ts","ng://angular-auth-oidc-client/lib/services/oidc.security.common.ts","ng://angular-auth-oidc-client/lib/services/oidc.security.validation.ts","ng://angular-auth-oidc-client/lib/services/oidc-security-state-validation.service.ts","ng://angular-auth-oidc-client/lib/services/oidc.security.check-session.ts","ng://angular-auth-oidc-client/lib/services/oidc.security.config.service.ts","ng://angular-auth-oidc-client/lib/services/oidc.security.silent-renew.ts","ng://angular-auth-oidc-client/lib/services/oidc.security.user-service.ts","ng://angular-auth-oidc-client/lib/services/uri-encoder.ts","ng://angular-auth-oidc-client/lib/services/oidc.security.service.ts","ng://angular-auth-oidc-client/lib/modules/auth.module.ts"],"names":["JwtKeys","this","keys","kty","use","kid","x5t","e","n","x5c","AuthorizationResult","authorizationState","validationResult","authorized","forbidden","unauthorized","NotSet","StatesDoNotMatch","SignatureFailed","IncorrectNonce","RequiredPropertyMissing","MaxOffsetExpired","IssDoesNotMatchIssuer","NoAuthWellKnownEndPoints","IncorrectAud","TokenExpired","IncorrectAtHash","Ok","LoginRequired","SecureTokenServerError","ValidateStateResult","access_token","id_token","authResponseIsValid","decoded_id_token","state","ValidationResult","OidcDataService","prototype","getWellknownEndpoints","url","headers","HttpHeaders","set","httpClient","get","getIdentityUserData","token","decodeURIComponent","Injectable","HttpClient","__assign","Object","assign","t","s","i","arguments","length","p","hasOwnProperty","call","apply","__values","o","m","Symbol","iterator","next","value","done","PlatformProvider","defineProperty","isPlatformBrowser","platformId","args","providedIn","decorators","type","Inject","PLATFORM_ID","ConfigurationProvider","mergedOpenIdConfiguration","authWellKnownEndpoints","onConfigurationChangeInternal","asObservable","setup","passedOpenIfConfiguration","passedAuthWellKnownEndpoints","setSpecialCases","currentConfig","platformProvider","isBrowser","start_checksession","silent_renew","DEFAULT_CONFIG","stsServer","redirect_url","client_id","response_type","scope","hd_param","post_logout_redirect_uri","silent_renew_url","silent_renew_offset_in_seconds","post_login_route","forbidden_route","unauthorized_route","auto_userinfo","auto_clean_state_after_authentication","trigger_authorization_result_event","log_console_warning_active","log_console_debug_active","iss_validation_off","history_cleanup_off","max_id_token_iat_offset_allowed_in_seconds","disable_iat_offset_validation","storage","Storage","sessionStorage","INITIAL_AUTHWELLKNOWN","issuer","jwks_uri","authorization_endpoint","token_endpoint","userinfo_endpoint","end_session_endpoint","check_session_iframe","revocation_endpoint","introspection_endpoint","Subject","LoggerService","logError","message","console","error","logWarning","configurationProvider","openIDConfiguration","warn","logDebug","log","IFrameService","getExistingIFrame","identifier","iFrameOnParent","getIFrameFromParentWindow","getIFrameFromWindow","addIFrameToWindowBody","sessionIframe","window","document","createElement","id","loggerService","style","display","body","appendChild","parent","getElementById","EqualityHelperService","areEqual","value1","value2","bothValuesAreArrays","arraysEqual","bothValuesAreStrings","bothValuesAreObjects","JSON","stringify","toLowerCase","oneValueIsStringAndTheOtherIsArray","Array","isArray","valueIsString","valueIsObject","String","arr1","arr2","TokenHelperService","getTokenExpirationDate","dataIdToken","Date","date","setUTCSeconds","exp","getHeaderFromToken","encoded","tokenIsValid","getPartOfToken","getPayloadFromToken","getSignatureFromToken","index","partOfToken","extractPartOfToken","result","urlBase64Decode","parse","str","output","replace","Error","decoded","atob","Buffer","toString","split","map","c","charCodeAt","slice","join","err","includes","PARTS_OF_TOKEN","OidcSecurityStorage","BrowserStorage","read","key","hasStorage","configProvider","getItem","write","undefined","setItem","OidcSecurityCommon","retrieve","storage_auth_result","store","storage_access_token","storage_id_token","storage_is_authorized","storage_user_data","storage_auth_nonce","storage_code_verifier","storage_auth_state_control","storage_session_state","storage_silent_renew_running","storage_custom_request_params","oidcSecurityStorage","resetStorageData","isRenewProcess","getAccessToken","getIdToken","OidcSecurityValidation","isTokenExpired","offsetSeconds","tokenHelperService","validate_id_token_exp_not_expired","tokenExpirationDate","tokenExpirationValue","valueOf","nowWithOffset","tokenNotExpired","validate_required_id_token","validated","validate_id_token_iat_max_offset","max_offset_allowed_in_seconds","dateTime_iat_id_token","iat","validate_id_token_nonce","local_nonce","nonce","validate_id_token_iss","authWellKnownEndpoints_issuer","iss","validate_id_token_aud","aud","arrayHelperService","validateStateFromHashCallback","local_state","validate_userdata_sub_id_token","id_token_sub","userdata_sub","validate_signature_id_token","jwtkeys","header_data","constructor","alg","isValid","_h","tslib_1.__values","_j","publickey","KEYUTIL","getKey","KJUR","jws","JWS","verify","amountOfMatchingKeys","_d","_e","_f","_g","config_validate_response_type","validate_id_token_at_hash","at_hash","isCodeFlow","testdata","generate_at_hash","testValue","hash","crypto","Util","hashString","first128bits","substr","hextob64u","generate_code_verifier","code_challenge","StateValidationService","validateState","jwtKeys","toReturn","oidcSecurityValidation","oidcSecurityCommon","authStateControl","handleUnsuccessfulValidation","authNonce","wellKnownEndpoints","handleSuccessfulValidation","IFRAME_FOR_CHECK_SESSION_IDENTIFIER","OidcSecurityCheckSession","_onCheckSessionChanged","doesSessionExist","existingIFrame","iFrameService","init","_this","lastIFrameRefresh","iframeRefreshInterval","now","from","iframeMessageEvent","messageHandler","bind","addEventListener","contentWindow","location","Observable","create","observer","onload","complete","startCheckingSession","clientId","scheduledHeartBeat","pollServerSession","stopCheckingSession","clearScheduledHeartBeat","_pollServerSessionRecur","pipe","take","subscribe","session_state","sessionState","outstandingMessages","postMessage","setTimeout","heartBeatInterval","zone","runOutsideAngular","clearTimeout","origin","source","data","NgZone","OidcConfigService","configurationLoadedInternal","load","configUrl","switchMap","clientConfiguration","loadUsingConfiguration","catchError","of","toPromise","load_using_stsServer","load_using_custom_stsServer","authWellknownEndpoints","customConfig","clientConfig","ReplaySubject","IFRAME_FOR_SILENT_RENEW_IDENTIFIER","OidcSecuritySilentRenew","initRenew","isRenewInitialized","startRenew","OidcSecurityUserService","initUserData","userData","getUserData","setUserData","oidcDataService","UriEncoder","encodeKey","encodeURIComponent","encodeValue","decodeKey","decodeValue","OidcSecurityService","_onModuleSetup","_onAuthorizationResult","onConfigurationChange","setupModule","openIdConfiguration","oidcSecurityCheckSession","onCheckSessionChanged","checkSessionChanged","isAuthorized","idToken","setIsAuthorized","runTokenValidation","oidcSecuritySilentRenew","boundSilentRenewEvent","silentRenewEventHandler","instanceId_1","Math","random","boundSilentRenewInitEvent_1","detail","removeEventListener","dispatchEvent","CustomEvent","_userData","getIsModuleSetup","_isModuleSetup","getIsAuthorized","_isSetupAndAuthorized","getToken","_isAuthorized","getValue","getPayloadFromIdToken","encode","setState","getState","setCustomRequestParameters","params","customRequestParams","authorize","urlHandler","authWellKnownEndpointsLoaded","resetAuthorizationData","code_verifier","createAuthorizeUrl","redirectTo","authorizedCallbackWithCode","urlToCheck","urlParts","HttpParams","fromString","code","requestTokensWithCode","filter","isModuleSetup","requestTokensWithCodeProcedure","tokenRequestUrl","silentRenewRunning","post","response","obj","authorizedCodeFlowCallbackProcedure","authorizedCallbackProcedure","authorizedImplicitFlowCallbackProcedure","reduce","resultData","item","parts","shift","authorizedImplicitFlowCallback","href","authResult","history","replaceState","title","pathname","AuthorizationState","router","navigate","getSigningKeys","getValidatedStateResult","setAuthorizationData","getUserinfo","oidcSecurityUserService","sub","accessToken","logoff","id_token_hint","createEndSessionUrl","refreshSession","handleError","status","silentRenew","startCheckingSilentRenew","stopCheckingSilentRenew","_scheduledHeartBeat","runTokenValidationRunning","getEndSessionUrl","stateValidationService","prompt","authorizationUrl","encoder","append","customParams","forEach","authorizationEndsessionUrl","handleErrorGetSigningKeys","errMsg","Response","json","statusText","observableThrowError","silentRenewHeartBeatCheck","Router","moduleSetup","BehaviorSubject","onModuleSetup","race$","tap","race","timer","switchMapTo","shareReplay","isSetupAndAuthorized","AuthModule","forRoot","ngModule","providers","provide","useClass","NgModule"],"mappings":"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","sourcesContent":["export class JwtKeys {\n    keys: JwtKey[] = [];\n}\n\nexport class JwtKey {\n    kty = '';\n    use = '';\n    kid = '';\n    x5t = '';\n    e = '';\n    n = '';\n    x5c: any[] = [];\n}\n","import { AuthorizationState } from './authorization-state.enum';\nimport { ValidationResult } from './validation-result.enum';\n\nexport class AuthorizationResult {\n    constructor(\n        public authorizationState: AuthorizationState,\n        public validationResult: ValidationResult\n    ) {}\n}\n","export enum AuthorizationState {\n    authorized = 'authorized',\n    forbidden = 'forbidden',\n    unauthorized = 'unauthorized'\n}\n","export enum ValidationResult {\n    NotSet = 'NotSet',\n    StatesDoNotMatch = 'StatesDoNotMatch',\n    SignatureFailed = 'SignatureFailed',\n    IncorrectNonce = 'IncorrectNonce',\n    RequiredPropertyMissing = 'RequiredPropertyMissing',\n    MaxOffsetExpired = 'MaxOffsetExpired',\n    IssDoesNotMatchIssuer = 'IssDoesNotMatchIssuer',\n    NoAuthWellKnownEndPoints = 'NoAuthWellKnownEndPoints',\n    IncorrectAud = 'IncorrectAud',\n    TokenExpired = 'TokenExpired',\n    IncorrectAtHash = 'IncorrectAtHash',\n    Ok = 'Ok',\n    LoginRequired = 'LoginRequired',\n    SecureTokenServerError = 'SecureTokenServerError'\n}\n","import { ValidationResult } from './validation-result.enum';\n\nexport class ValidateStateResult {\n    constructor(\n        public access_token = '',\n        public id_token = '',\n        public authResponseIsValid = false,\n        public decoded_id_token: any = {},\n        public state: ValidationResult = ValidationResult.NotSet\n    ) {}\n}\n","import { HttpClient, HttpHeaders } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class OidcDataService {\n    constructor(private httpClient: HttpClient) {}\n\n    getWellknownEndpoints<T>(url: string): Observable<T> {\n        let headers = new HttpHeaders();\n        headers = headers.set('Accept', 'application/json');\n\n        return this.httpClient.get<T>(url, {\n            headers: headers,\n        });\n    }\n\n    getIdentityUserData<T>(url: string, token: string): Observable<T> {\n        let headers = new HttpHeaders();\n        headers = headers.set('Accept', 'application/json');\n        headers = headers.set('Authorization', 'Bearer ' + decodeURIComponent(token));\n\n        return this.httpClient.get<T>(url, {\n            headers: headers,\n        });\n    }\n\n    get<T>(url: string): Observable<T> {\n        let headers = new HttpHeaders();\n        headers = headers.set('Accept', 'application/json');\n\n        return this.httpClient.get<T>(url, {\n            headers: headers,\n        });\n    }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { isPlatformBrowser } from '@angular/common';\nimport { Inject, Injectable, PLATFORM_ID } from '@angular/core';\n\n@Injectable({ providedIn: 'root' })\nexport class PlatformProvider {\n    get isBrowser() {\n        return isPlatformBrowser(this.platformId);\n    }\n\n    constructor(@Inject(PLATFORM_ID) private platformId: Object) {}\n}\n","import { Injectable } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { OpenIdConfiguration, OpenIdInternalConfiguration } from '../models/auth.configuration';\nimport { AuthWellKnownEndpoints } from '../models/auth.well-known-endpoints';\nimport { PlatformProvider } from './platform.provider';\n\n@Injectable({ providedIn: 'root' })\nexport class ConfigurationProvider {\n    private DEFAULT_CONFIG: OpenIdInternalConfiguration = {\n        stsServer: 'https://please_set',\n        redirect_url: 'https://please_set',\n        client_id: 'please_set',\n        response_type: 'code',\n        scope: 'openid email profile',\n        hd_param: '',\n        post_logout_redirect_uri: 'https://please_set',\n        start_checksession: false,\n        silent_renew: false,\n        silent_renew_url: 'https://please_set',\n        silent_renew_offset_in_seconds: 0,\n        post_login_route: '/',\n        forbidden_route: '/forbidden',\n        unauthorized_route: '/unauthorized',\n        auto_userinfo: true,\n        auto_clean_state_after_authentication: true,\n        trigger_authorization_result_event: false,\n        log_console_warning_active: true,\n        log_console_debug_active: false,\n        iss_validation_off: false,\n        history_cleanup_off: false,\n        max_id_token_iat_offset_allowed_in_seconds: 3,\n        disable_iat_offset_validation: false,\n        storage: typeof Storage !== 'undefined' ? sessionStorage : null,\n    };\n\n    private INITIAL_AUTHWELLKNOWN: AuthWellKnownEndpoints = {\n        issuer: '',\n        jwks_uri: '',\n        authorization_endpoint: '',\n        token_endpoint: '',\n        userinfo_endpoint: '',\n        end_session_endpoint: '',\n        check_session_iframe: '',\n        revocation_endpoint: '',\n        introspection_endpoint: '',\n    };\n\n    private mergedOpenIdConfiguration: OpenIdInternalConfiguration = this.DEFAULT_CONFIG;\n    private authWellKnownEndpoints: AuthWellKnownEndpoints = this.INITIAL_AUTHWELLKNOWN;\n\n    private onConfigurationChangeInternal = new Subject<OpenIdConfiguration>();\n\n    get openIDConfiguration(): OpenIdInternalConfiguration {\n        return this.mergedOpenIdConfiguration;\n    }\n\n    get wellKnownEndpoints(): AuthWellKnownEndpoints {\n        return this.authWellKnownEndpoints;\n    }\n\n    get onConfigurationChange() {\n        return this.onConfigurationChangeInternal.asObservable();\n    }\n\n    constructor(private platformProvider: PlatformProvider) {}\n\n    setup(passedOpenIfConfiguration: OpenIdConfiguration, passedAuthWellKnownEndpoints: AuthWellKnownEndpoints) {\n        this.mergedOpenIdConfiguration = { ...this.mergedOpenIdConfiguration, ...passedOpenIfConfiguration };\n        this.setSpecialCases(this.mergedOpenIdConfiguration);\n        this.authWellKnownEndpoints = { ...passedAuthWellKnownEndpoints };\n        this.onConfigurationChangeInternal.next({ ...this.mergedOpenIdConfiguration });\n    }\n\n    private setSpecialCases(currentConfig: OpenIdConfiguration) {\n        if (!this.platformProvider.isBrowser) {\n            currentConfig.start_checksession = false;\n            currentConfig.silent_renew = false;\n        }\n    }\n}\n","import { Injectable } from '@angular/core';\nimport { ConfigurationProvider } from './auth-configuration.provider';\n\n@Injectable()\nexport class LoggerService {\n    constructor(private configurationProvider: ConfigurationProvider) {}\n\n    logError(message: any) {\n        console.error(message);\n    }\n\n    logWarning(message: any) {\n        if (this.configurationProvider.openIDConfiguration.log_console_warning_active) {\n            console.warn(message);\n        }\n    }\n\n    logDebug(message: any) {\n        if (this.configurationProvider.openIDConfiguration.log_console_debug_active) {\n            console.log(message);\n        }\n    }\n}\n","import { Injectable } from '@angular/core';\nimport { LoggerService } from './oidc.logger.service';\n\n@Injectable()\nexport class IFrameService {\n    constructor(private loggerService: LoggerService) {}\n\n    getExistingIFrame(identifier: string) {\n        const iFrameOnParent = this.getIFrameFromParentWindow(identifier);\n\n        if (iFrameOnParent) {\n            return iFrameOnParent;\n        }\n\n        return this.getIFrameFromWindow(identifier);\n    }\n\n    addIFrameToWindowBody(identifier: string) {\n        const sessionIframe = window.document.createElement('iframe');\n        sessionIframe.id = identifier;\n        this.loggerService.logDebug(sessionIframe);\n        sessionIframe.style.display = 'none';\n        window.document.body.appendChild(sessionIframe);\n        return sessionIframe;\n    }\n\n    private getIFrameFromParentWindow(identifier: string) {\n        try {\n            return window.parent.document.getElementById(identifier);\n        } catch (e) {\n            return null;\n        }\n    }\n\n    private getIFrameFromWindow(identifier: string) {\n        return window.document.getElementById(identifier);\n    }\n}\n","import { Injectable } from '@angular/core';\n\n@Injectable()\nexport class EqualityHelperService {\n    areEqual(value1: string | any[] | object | null | undefined, value2: string | any[] | object | null | undefined) {\n        if (!value1 || !value2) {\n            return false;\n        }\n\n        if (this.bothValuesAreArrays(value1, value2)) {\n            return this.arraysEqual(value1 as any[], value2 as any[]);\n        }\n\n        if (this.bothValuesAreStrings(value1, value2)) {\n            return value1 === value2;\n        }\n\n        if (this.bothValuesAreObjects(value1, value2)) {\n            return JSON.stringify(value1).toLowerCase() === JSON.stringify(value2).toLowerCase();\n        }\n\n        if (this.oneValueIsStringAndTheOtherIsArray(value1, value2)) {\n            if (Array.isArray(value1) && this.valueIsString(value2)) {\n                return value1[0] === value2;\n            }\n            if (Array.isArray(value2) && this.valueIsString(value1)) {\n                return value2[0] === value1;\n            }\n        }\n    }\n\n    private oneValueIsStringAndTheOtherIsArray(value1: string | object | any[], value2: string | object | any[]) {\n        return (Array.isArray(value1) && this.valueIsString(value2)) || (Array.isArray(value2) && this.valueIsString(value1));\n    }\n\n    private bothValuesAreObjects(value1: string | object | any[], value2: string | object | any[]) {\n        return this.valueIsObject(value1) && this.valueIsObject(value2);\n    }\n\n    private bothValuesAreStrings(value1: string | object | any[], value2: string | object | any[]) {\n        return this.valueIsString(value1) && this.valueIsString(value2);\n    }\n\n    private bothValuesAreArrays(value1: string | object | any[], value2: string | object | any[]) {\n        return Array.isArray(value1) && Array.isArray(value2);\n    }\n\n    private valueIsString(value: any) {\n        return typeof value === 'string' || value instanceof String;\n    }\n\n    private valueIsObject(value: any) {\n        return typeof value === 'object';\n    }\n\n    private arraysEqual(arr1: Array<string>, arr2: Array<string>) {\n        if (arr1.length !== arr2.length) {\n            return false;\n        }\n\n        for (let i = arr1.length; i--; ) {\n            if (arr1[i] !== arr2[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n","import { Injectable } from '@angular/core';\nimport { LoggerService } from './oidc.logger.service';\n\n@Injectable()\nexport class TokenHelperService {\n    private PARTS_OF_TOKEN = 3;\n    constructor(private readonly loggerService: LoggerService) {}\n\n    getTokenExpirationDate(dataIdToken: any): Date {\n        if (!dataIdToken.hasOwnProperty('exp')) {\n            return new Date();\n        }\n\n        const date = new Date(0); // The 0 here is the key, which sets the date to the epoch\n        date.setUTCSeconds(dataIdToken.exp);\n\n        return date;\n    }\n\n    getHeaderFromToken(token: any, encoded: boolean) {\n        if (!this.tokenIsValid(token)) {\n            return {};\n        }\n\n        return this.getPartOfToken(token, 0, encoded);\n    }\n\n    getPayloadFromToken(token: any, encoded: boolean) {\n        if (!this.tokenIsValid(token)) {\n            return {};\n        }\n\n        return this.getPartOfToken(token, 1, encoded);\n    }\n\n    getSignatureFromToken(token: any, encoded: boolean) {\n        if (!this.tokenIsValid(token)) {\n            return {};\n        }\n\n        return this.getPartOfToken(token, 2, encoded);\n    }\n\n    private getPartOfToken(token: string, index: number, encoded: boolean) {\n        const partOfToken = this.extractPartOfToken(token, index);\n\n        if (encoded) {\n            return partOfToken;\n        }\n\n        const result = this.urlBase64Decode(partOfToken);\n        return JSON.parse(result);\n    }\n\n    private urlBase64Decode(str: string) {\n        let output = str.replace(/-/g, '+').replace(/_/g, '/');\n        switch (output.length % 4) {\n            case 0:\n                break;\n            case 2:\n                output += '==';\n                break;\n            case 3:\n                output += '=';\n                break;\n            default:\n                throw Error('Illegal base64url string!');\n        }\n\n        const decoded = typeof window !== 'undefined' ? window.atob(output) : new Buffer(output, 'base64').toString('binary');\n\n        try {\n            // Going backwards: from bytestream, to percent-encoding, to original string.\n            return decodeURIComponent(decoded.split('')\n                .map((c: string) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))\n                .join(''));\n        } catch (err) {\n            return decoded;\n        }\n    }\n\n    private tokenIsValid(token: string) {\n        if (!token) {\n            this.loggerService.logError(`token '${token}' is not valid --> token falsy`);\n            return false;\n        }\n\n        if (!(token as string).includes('.')) {\n            this.loggerService.logError(`token '${token}' is not valid --> no dots included`);\n            return false;\n        }\n\n        const parts = token.split('.');\n\n        if (parts.length !== this.PARTS_OF_TOKEN) {\n            this.loggerService.logError(`token '${token}' is not valid --> token has t have exact three dots`);\n            return false;\n        }\n\n        return true;\n    }\n\n    private extractPartOfToken(token: string, index: number) {\n        return token.split('.')[index];\n    }\n}\n","import { Injectable } from '@angular/core';\nimport { ConfigurationProvider } from './auth-configuration.provider';\n\n/**\n * Implement this class-interface to create a custom storage.\n */\n@Injectable()\nexport abstract class OidcSecurityStorage {\n    /**\n     * This method must contain the logic to read the storage.\n     * @param key\n     * @return The value of the given key\n     */\n    public abstract read(key: string): any;\n\n    /**\n     * This method must contain the logic to write the storage.\n     * @param key\n     * @param value The value for the given key\n     */\n    public abstract write(key: string, value: any): void;\n}\n\n@Injectable()\nexport class BrowserStorage implements OidcSecurityStorage {\n    private hasStorage: boolean;\n\n    constructor(private configProvider: ConfigurationProvider) {\n        this.hasStorage = typeof Storage !== 'undefined';\n    }\n\n    public read(key: string): any {\n        if (this.hasStorage) {\n            return JSON.parse(this.configProvider.openIDConfiguration.storage.getItem(key + '_' + this.configProvider.openIDConfiguration.client_id));\n        }\n\n        return;\n    }\n\n    public write(key: string, value: any): void {\n        if (this.hasStorage) {\n            value = value === undefined ? null : value;\n            this.configProvider.openIDConfiguration.storage.setItem(\n                key + '_' + this.configProvider.openIDConfiguration.client_id,\n                JSON.stringify(value)\n            );\n        }\n    }\n}\n","import { Injectable } from '@angular/core';\nimport { OidcSecurityStorage } from './oidc.security.storage';\n\nexport type SilentRenewState = 'running' | '';\n\n@Injectable()\nexport class OidcSecurityCommon {\n    private storage_auth_result = 'authorizationResult';\n\n    public get authResult(): any {\n        return this.retrieve(this.storage_auth_result);\n    }\n\n    public set authResult(value: any) {\n        this.store(this.storage_auth_result, value);\n    }\n\n    private storage_access_token = 'authorizationData';\n\n    public get accessToken(): string {\n        return this.retrieve(this.storage_access_token) || '';\n    }\n\n    public set accessToken(value: string) {\n        this.store(this.storage_access_token, value);\n    }\n\n    private storage_id_token = 'authorizationDataIdToken';\n\n    public get idToken(): string {\n        return this.retrieve(this.storage_id_token) || '';\n    }\n\n    public set idToken(value: string) {\n        this.store(this.storage_id_token, value);\n    }\n\n    private storage_is_authorized = '_isAuthorized';\n\n    public get isAuthorized(): boolean | undefined {\n        return this.retrieve(this.storage_is_authorized);\n    }\n\n    public set isAuthorized(value: boolean | undefined) {\n        this.store(this.storage_is_authorized, value);\n    }\n\n    private storage_user_data = 'userData';\n\n    public get userData(): any {\n        return this.retrieve(this.storage_user_data);\n    }\n\n    public set userData(value: any) {\n        this.store(this.storage_user_data, value);\n    }\n\n    private storage_auth_nonce = 'authNonce';\n\n    public get authNonce(): string {\n        return this.retrieve(this.storage_auth_nonce) || '';\n    }\n\n    public set authNonce(value: string) {\n        this.store(this.storage_auth_nonce, value);\n    }\n\n    private storage_code_verifier = 'code_verifier';\n\n    public get code_verifier(): string {\n        return this.retrieve(this.storage_code_verifier) || '';\n    }\n\n    public set code_verifier(value: string) {\n        this.store(this.storage_code_verifier, value);\n    }\n\n    private storage_auth_state_control = 'authStateControl';\n\n    public get authStateControl(): string {\n        return this.retrieve(this.storage_auth_state_control) || '';\n    }\n\n    public set authStateControl(value: string) {\n        this.store(this.storage_auth_state_control, value);\n    }\n\n    private storage_session_state = 'session_state';\n\n    public get sessionState(): any {\n        return this.retrieve(this.storage_session_state);\n    }\n\n    public set sessionState(value: any) {\n        this.store(this.storage_session_state, value);\n    }\n\n    private storage_silent_renew_running = 'storage_silent_renew_running';\n\n    public get silentRenewRunning(): SilentRenewState {\n        return this.retrieve(this.storage_silent_renew_running) || '';\n    }\n\n    public set silentRenewRunning(value: SilentRenewState) {\n        this.store(this.storage_silent_renew_running, value);\n    }\n\n    private storage_custom_request_params = 'storage_custom_request_params';\n\n    public get customRequestParams(): {\n        [key: string]: string | number | boolean;\n    } {\n        return this.retrieve(this.storage_custom_request_params);\n    }\n\n    public set customRequestParams(value: { [key: string]: string | number | boolean }) {\n        this.store(this.storage_custom_request_params, value);\n    }\n\n    constructor(private oidcSecurityStorage: OidcSecurityStorage) {}\n\n    private retrieve(key: string): any {\n        return this.oidcSecurityStorage.read(key);\n    }\n\n    private store(key: string, value: any) {\n        this.oidcSecurityStorage.write(key, value);\n    }\n\n    resetStorageData(isRenewProcess: boolean) {\n        if (!isRenewProcess) {\n            this.store(this.storage_auth_result, '');\n            this.store(this.storage_session_state, '');\n            this.store(this.storage_silent_renew_running, '');\n            this.store(this.storage_is_authorized, false);\n            this.store(this.storage_access_token, '');\n            this.store(this.storage_id_token, '');\n            this.store(this.storage_user_data, '');\n            this.store(this.storage_code_verifier, '');\n        }\n    }\n\n    getAccessToken(): any {\n        return this.retrieve(this.storage_access_token);\n    }\n\n    getIdToken(): any {\n        return this.retrieve(this.storage_id_token);\n    }\n}\n","import { Injectable } from '@angular/core';\nimport { hextob64u, KEYUTIL, KJUR } from 'jsrsasign';\nimport { EqualityHelperService } from './oidc-equality-helper.service';\nimport { TokenHelperService } from './oidc-token-helper.service';\nimport { LoggerService } from './oidc.logger.service';\n\n// http://openid.net/specs/openid-connect-implicit-1_0.html\n\n// id_token\n// id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)\n// MUST exactly match the value of the iss (issuer) Claim.\n//\n// id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified\n// by the iss (issuer) Claim as an audience.The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience,\n// or if it contains additional audiences not trusted by the Client.\n//\n// id_token C3: If the ID Token contains multiple audiences, the Client SHOULD verify that an azp Claim is present.\n//\n// id_token C4: If an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.\n//\n// id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the\n// alg Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.\n//\n// id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the OpenID Connect Core 1.0\n// [OpenID.Core] specification.\n//\n// id_token C7: The current time MUST be before the time represented by the exp Claim (possibly allowing for some small leeway to account\n// for clock skew).\n//\n// id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,\n// limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.\n//\n// id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one that was sent\n// in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.The precise method for detecting replay attacks\n// is Client specific.\n//\n// id_token C10: If the acr Claim was requested, the Client SHOULD check that the asserted Claim Value is appropriate.\n// The meaning and processing of acr Claim Values is out of scope for this document.\n//\n// id_token C11: When a max_age request is made, the Client SHOULD check the auth_time Claim value and request re- authentication\n// if it determines too much time has elapsed since the last End- User authentication.\n\n// Access Token Validation\n// access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]\n// for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.\n// access_token C2: Take the left- most half of the hash and base64url- encode it.\n// access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash is present in the ID Token.\n\n@Injectable()\nexport class OidcSecurityValidation {\n    constructor(\n        private arrayHelperService: EqualityHelperService,\n        private tokenHelperService: TokenHelperService,\n        private loggerService: LoggerService\n    ) {}\n\n    // id_token C7: The current time MUST be before the time represented by the exp Claim (possibly allowing for some small leeway to account for clock skew).\n    isTokenExpired(token: string, offsetSeconds?: number): boolean {\n        let decoded: any;\n        decoded = this.tokenHelperService.getPayloadFromToken(token, false);\n\n        return !this.validate_id_token_exp_not_expired(decoded, offsetSeconds);\n    }\n\n    // id_token C7: The current time MUST be before the time represented by the exp Claim (possibly allowing for some small leeway to account for clock skew).\n    validate_id_token_exp_not_expired(decoded_id_token: string, offsetSeconds?: number): boolean {\n        const tokenExpirationDate = this.tokenHelperService.getTokenExpirationDate(decoded_id_token);\n        offsetSeconds = offsetSeconds || 0;\n\n        if (!tokenExpirationDate) {\n            return false;\n        }\n\n        const tokenExpirationValue = tokenExpirationDate.valueOf();\n        const nowWithOffset = new Date().valueOf() + offsetSeconds * 1000;\n        const tokenNotExpired = tokenExpirationValue > nowWithOffset;\n\n        this.loggerService.logDebug(`Token not expired?: ${tokenExpirationValue} > ${nowWithOffset}  (${tokenNotExpired})`);\n\n        // Token not expired?\n        return tokenNotExpired;\n    }\n\n    // iss\n    // REQUIRED. Issuer Identifier for the Issuer of the response.The iss value is a case-sensitive URL using the https scheme that contains scheme, host,\n    // and optionally, port number and path components and no query or fragment components.\n    //\n    // sub\n    // REQUIRED. Subject Identifier.Locally unique and never reassigned identifier within the Issuer for the End- User,\n    // which is intended to be consumed by the Client, e.g., 24400320 or AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4.\n    // It MUST NOT exceed 255 ASCII characters in length.The sub value is a case-sensitive string.\n    //\n    // aud\n    // REQUIRED. Audience(s) that this ID Token is intended for. It MUST contain the OAuth 2.0 client_id of the Relying Party as an audience value.\n    // It MAY also contain identifiers for other audiences.In the general case, the aud value is an array of case-sensitive strings.\n    // In the common special case when there is one audience, the aud value MAY be a single case-sensitive string.\n    //\n    // exp\n    // REQUIRED. Expiration time on or after which the ID Token MUST NOT be accepted for processing.\n    // The processing of this parameter requires that the current date/ time MUST be before the expiration date/ time listed in the value.\n    // Implementers MAY provide for some small leeway, usually no more than a few minutes, to account for clock skew.\n    // Its value is a JSON [RFC7159] number representing the number of seconds from 1970- 01 - 01T00: 00:00Z as measured in UTC until the date/ time.\n    // See RFC 3339 [RFC3339] for details regarding date/ times in general and UTC in particular.\n    //\n    // iat\n    // REQUIRED. Time at which the JWT was issued. Its value is a JSON number representing the number of seconds from 1970- 01 - 01T00: 00:00Z as measured\n    // in UTC until the date/ time.\n    validate_required_id_token(dataIdToken: any): boolean {\n        let validated = true;\n        if (!dataIdToken.hasOwnProperty('iss')) {\n            validated = false;\n            this.loggerService.logWarning('iss is missing, this is required in the id_token');\n        }\n\n        if (!dataIdToken.hasOwnProperty('sub')) {\n            validated = false;\n            this.loggerService.logWarning('sub is missing, this is required in the id_token');\n        }\n\n        if (!dataIdToken.hasOwnProperty('aud')) {\n            validated = false;\n            this.loggerService.logWarning('aud is missing, this is required in the id_token');\n        }\n\n        if (!dataIdToken.hasOwnProperty('exp')) {\n            validated = false;\n            this.loggerService.logWarning('exp is missing, this is required in the id_token');\n        }\n\n        if (!dataIdToken.hasOwnProperty('iat')) {\n            validated = false;\n            this.loggerService.logWarning('iat is missing, this is required in the id_token');\n        }\n\n        return validated;\n    }\n\n    // id_token C8: The iat Claim can be used to reject tokens that were issued too far away from the current time,\n    // limiting the amount of time that nonces need to be stored to prevent attacks.The acceptable range is Client specific.\n    validate_id_token_iat_max_offset(dataIdToken: any,\n        max_offset_allowed_in_seconds: number,\n        disable_iat_offset_validation: boolean): boolean {\n\n        if (disable_iat_offset_validation) {\n            return true;\n        }\n\n        if (!dataIdToken.hasOwnProperty('iat')) {\n            return false;\n        }\n\n        const dateTime_iat_id_token = new Date(0); // The 0 here is the key, which sets the date to the epoch\n        dateTime_iat_id_token.setUTCSeconds(dataIdToken.iat);\n\n        max_offset_allowed_in_seconds = max_offset_allowed_in_seconds || 0;\n\n        if (dateTime_iat_id_token == null) {\n            return false;\n        }\n\n        this.loggerService.logDebug(\n            'validate_id_token_iat_max_offset: ' +\n                (new Date().valueOf() - dateTime_iat_id_token.valueOf()) +\n                ' < ' +\n                max_offset_allowed_in_seconds * 1000\n        );\n        return new Date().valueOf() - dateTime_iat_id_token.valueOf() < max_offset_allowed_in_seconds * 1000;\n    }\n\n    // id_token C9: The value of the nonce Claim MUST be checked to verify that it is the same value as the one\n    // that was sent in the Authentication Request.The Client SHOULD check the nonce value for replay attacks.\n    // The precise method for detecting replay attacks is Client specific.\n    validate_id_token_nonce(dataIdToken: any, local_nonce: any): boolean {\n        if (dataIdToken.nonce !== local_nonce) {\n            this.loggerService.logDebug('Validate_id_token_nonce failed, dataIdToken.nonce: ' + dataIdToken.nonce + ' local_nonce:' + local_nonce);\n            return false;\n        }\n\n        return true;\n    }\n\n    // id_token C1: The Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery)\n    // MUST exactly match the value of the iss (issuer) Claim.\n    validate_id_token_iss(dataIdToken: any, authWellKnownEndpoints_issuer: any): boolean {\n        if ((dataIdToken.iss as string) !== (authWellKnownEndpoints_issuer as string)) {\n            this.loggerService.logDebug(\n                'Validate_id_token_iss failed, dataIdToken.iss: ' +\n                    dataIdToken.iss +\n                    ' authWellKnownEndpoints issuer:' +\n                    authWellKnownEndpoints_issuer\n            );\n            return false;\n        }\n\n        return true;\n    }\n\n    // id_token C2: The Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified\n    // by the iss (issuer) Claim as an audience.\n    // The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience, or if it contains additional audiences\n    // not trusted by the Client.\n    validate_id_token_aud(dataIdToken: any, aud: any): boolean {\n        if (dataIdToken.aud instanceof Array) {\n            const result = this.arrayHelperService.areEqual(dataIdToken.aud, aud);\n\n            if (!result) {\n                this.loggerService.logDebug('Validate_id_token_aud  array failed, dataIdToken.aud: ' + dataIdToken.aud + ' client_id:' + aud);\n                return false;\n            }\n\n            return true;\n        } else if (dataIdToken.aud !== aud) {\n            this.loggerService.logDebug('Validate_id_token_aud failed, dataIdToken.aud: ' + dataIdToken.aud + ' client_id:' + aud);\n\n            return false;\n        }\n\n        return true;\n    }\n\n    validateStateFromHashCallback(state: any, local_state: any): boolean {\n        if ((state as string) !== (local_state as string)) {\n            this.loggerService.logDebug('ValidateStateFromHashCallback failed, state: ' + state + ' local_state:' + local_state);\n            return false;\n        }\n\n        return true;\n    }\n\n    validate_userdata_sub_id_token(id_token_sub: any, userdata_sub: any): boolean {\n        if ((id_token_sub as string) !== (userdata_sub as string)) {\n            this.loggerService.logDebug('validate_userdata_sub_id_token failed, id_token_sub: ' + id_token_sub + ' userdata_sub:' + userdata_sub);\n            return false;\n        }\n\n        return true;\n    }\n\n    // id_token C5: The Client MUST validate the signature of the ID Token according to JWS [JWS] using the algorithm specified in the alg\n    // Header Parameter of the JOSE Header.The Client MUST use the keys provided by the Issuer.\n    // id_token C6: The alg value SHOULD be RS256. Validation of tokens using other signing algorithms is described in the\n    // OpenID Connect Core 1.0 [OpenID.Core] specification.\n    validate_signature_id_token(id_token: any, jwtkeys: any): boolean {\n        if (!jwtkeys || !jwtkeys.keys) {\n            return false;\n        }\n\n        const header_data = this.tokenHelperService.getHeaderFromToken(id_token, false);\n\n        if (Object.keys(header_data).length === 0 && header_data.constructor === Object) {\n            this.loggerService.logWarning('id token has no header data');\n            return false;\n        }\n\n        const kid = header_data.kid;\n        const alg = header_data.alg;\n\n        if ('RS256' !== (alg as string)) {\n            this.loggerService.logWarning('Only RS256 supported');\n            return false;\n        }\n\n        let isValid = false;\n\n        if (!header_data.hasOwnProperty('kid')) {\n            // exactly 1 key in the jwtkeys and no kid in the Jose header\n            // kty\t\"RSA\" use \"sig\"\n            let amountOfMatchingKeys = 0;\n            for (const key of jwtkeys.keys) {\n                if ((key.kty as string) === 'RSA' && (key.use as string) === 'sig') {\n                    amountOfMatchingKeys = amountOfMatchingKeys + 1;\n                }\n            }\n\n            if (amountOfMatchingKeys === 0) {\n                this.loggerService.logWarning('no keys found, incorrect Signature, validation failed for id_token');\n                return false;\n            } else if (amountOfMatchingKeys > 1) {\n                this.loggerService.logWarning('no ID Token kid claim in JOSE header and multiple supplied in jwks_uri');\n                return false;\n            } else {\n                for (const key of jwtkeys.keys) {\n                    if ((key.kty as string) === 'RSA' && (key.use as string) === 'sig') {\n                        const publickey = KEYUTIL.getKey(key);\n                        isValid = KJUR.jws.JWS.verify(id_token, publickey, ['RS256']);\n                        if (!isValid) {\n                            this.loggerService.logWarning('incorrect Signature, validation failed for id_token');\n                        }\n                        return isValid;\n                    }\n                }\n            }\n        } else {\n            // kid in the Jose header of id_token\n            for (const key of jwtkeys.keys) {\n                if ((key.kid as string) === (kid as string)) {\n                    const publickey = KEYUTIL.getKey(key);\n                    isValid = KJUR.jws.JWS.verify(id_token, publickey, ['RS256']);\n                    if (!isValid) {\n                        this.loggerService.logWarning('incorrect Signature, validation failed for id_token');\n                    }\n                    return isValid;\n                }\n            }\n        }\n\n        return isValid;\n    }\n\n    config_validate_response_type(response_type: string): boolean {\n        if (response_type === 'id_token token' || response_type === 'id_token') {\n            return true;\n        }\n\n        if (response_type === 'code') {\n            return true;\n        }\n\n        this.loggerService.logWarning('module configure incorrect, invalid response_type:' + response_type);\n        return false;\n    }\n\n    // Accepts ID Token without 'kid' claim in JOSE header if only one JWK supplied in 'jwks_url'\n    //// private validate_no_kid_in_header_only_one_allowed_in_jwtkeys(header_data: any, jwtkeys: any): boolean {\n    ////    this.oidcSecurityCommon.logDebug('amount of jwtkeys.keys: ' + jwtkeys.keys.length);\n    ////    if (!header_data.hasOwnProperty('kid')) {\n    ////        // no kid defined in Jose header\n    ////        if (jwtkeys.keys.length != 1) {\n    ////            this.oidcSecurityCommon.logDebug('jwtkeys.keys.length != 1 and no kid in header');\n    ////            return false;\n    ////        }\n    ////    }\n\n    ////    return true;\n    //// }\n\n    // Access Token Validation\n    // access_token C1: Hash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA[JWA]\n    // for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.\n    // access_token C2: Take the left- most half of the hash and base64url- encode it.\n    // access_token C3: The value of at_hash in the ID Token MUST match the value produced in the previous step if at_hash\n    // is present in the ID Token.\n    validate_id_token_at_hash(access_token: any, at_hash: any, isCodeFlow: boolean): boolean {\n        this.loggerService.logDebug('at_hash from the server:' + at_hash);\n\n        // The at_hash is optional for the code flow\n        if (isCodeFlow) {\n            if (!(at_hash as string)) {\n                this.loggerService.logDebug('Code Flow active, and no at_hash in the id_token, skipping check!');\n                return true;\n            }\n        }\n\n        const testdata = this.generate_at_hash('' + access_token);\n        this.loggerService.logDebug('at_hash client validation not decoded:' + testdata);\n        if (testdata === (at_hash as string)) {\n            return true; // isValid;\n        } else {\n            const testValue = this.generate_at_hash('' + decodeURIComponent(access_token));\n            this.loggerService.logDebug('-gen access--' + testValue);\n            if (testValue === (at_hash as string)) {\n                return true; // isValid\n            }\n        }\n\n        return false;\n    }\n\n    private generate_at_hash(access_token: any): string {\n        const hash = KJUR.crypto.Util.hashString(access_token, 'sha256');\n        const first128bits = hash.substr(0, hash.length / 2);\n        const testdata = hextob64u(first128bits);\n\n        return testdata;\n    }\n\n    generate_code_verifier(code_challenge: any): string {\n        const hash = KJUR.crypto.Util.hashString(code_challenge, 'sha256');\n        const testdata = hextob64u(hash);\n\n        return testdata;\n    }\n}\n","import { Injectable } from '@angular/core';\nimport { JwtKeys } from '../models/jwtkeys';\nimport { ValidateStateResult } from '../models/validate-state-result.model';\nimport { ValidationResult } from '../models/validation-result.enum';\nimport { ConfigurationProvider } from './auth-configuration.provider';\nimport { TokenHelperService } from './oidc-token-helper.service';\nimport { LoggerService } from './oidc.logger.service';\nimport { OidcSecurityCommon } from './oidc.security.common';\nimport { OidcSecurityValidation } from './oidc.security.validation';\n\n@Injectable()\nexport class StateValidationService {\n    constructor(\n        public oidcSecurityCommon: OidcSecurityCommon,\n        private oidcSecurityValidation: OidcSecurityValidation,\n        private tokenHelperService: TokenHelperService,\n        private loggerService: LoggerService,\n        private readonly configurationProvider: ConfigurationProvider\n    ) {}\n\n    validateState(result: any, jwtKeys: JwtKeys): ValidateStateResult {\n        const toReturn = new ValidateStateResult();\n        if (!this.oidcSecurityValidation.validateStateFromHashCallback(result.state, this.oidcSecurityCommon.authStateControl)) {\n            this.loggerService.logWarning('authorizedCallback incorrect state');\n            toReturn.state = ValidationResult.StatesDoNotMatch;\n            this.handleUnsuccessfulValidation();\n            return toReturn;\n        }\n\n        if (\n            this.configurationProvider.openIDConfiguration.response_type === 'id_token token' ||\n            this.configurationProvider.openIDConfiguration.response_type === 'code'\n        ) {\n            toReturn.access_token = result.access_token;\n        }\n\n        toReturn.id_token = result.id_token;\n\n        toReturn.decoded_id_token = this.tokenHelperService.getPayloadFromToken(toReturn.id_token, false);\n\n        if (!this.oidcSecurityValidation.validate_signature_id_token(toReturn.id_token, jwtKeys)) {\n            this.loggerService.logDebug('authorizedCallback Signature validation failed id_token');\n            toReturn.state = ValidationResult.SignatureFailed;\n            this.handleUnsuccessfulValidation();\n            return toReturn;\n        }\n\n        if (!this.oidcSecurityValidation.validate_id_token_nonce(toReturn.decoded_id_token, this.oidcSecurityCommon.authNonce)) {\n            this.loggerService.logWarning('authorizedCallback incorrect nonce');\n            toReturn.state = ValidationResult.IncorrectNonce;\n            this.handleUnsuccessfulValidation();\n            return toReturn;\n        }\n\n        if (!this.oidcSecurityValidation.validate_required_id_token(toReturn.decoded_id_token)) {\n            this.loggerService.logDebug('authorizedCallback Validation, one of the REQUIRED properties missing from id_token');\n            toReturn.state = ValidationResult.RequiredPropertyMissing;\n            this.handleUnsuccessfulValidation();\n            return toReturn;\n        }\n\n        if (\n            !this.oidcSecurityValidation.validate_id_token_iat_max_offset(\n                toReturn.decoded_id_token,\n                this.configurationProvider.openIDConfiguration.max_id_token_iat_offset_allowed_in_seconds,\n                this.configurationProvider.openIDConfiguration.disable_iat_offset_validation\n            )\n        ) {\n            this.loggerService.logWarning('authorizedCallback Validation, iat rejected id_token was issued too far away from the current time');\n            toReturn.state = ValidationResult.MaxOffsetExpired;\n            this.handleUnsuccessfulValidation();\n            return toReturn;\n        }\n\n        if (this.configurationProvider.wellKnownEndpoints) {\n            if (this.configurationProvider.openIDConfiguration.iss_validation_off) {\n                this.loggerService.logDebug('iss validation is turned off, this is not recommended!');\n            } else if (\n                !this.configurationProvider.openIDConfiguration.iss_validation_off &&\n                !this.oidcSecurityValidation.validate_id_token_iss(toReturn.decoded_id_token, this.configurationProvider.wellKnownEndpoints.issuer)\n            ) {\n                this.loggerService.logWarning('authorizedCallback incorrect iss does not match authWellKnownEndpoints issuer');\n                toReturn.state = ValidationResult.IssDoesNotMatchIssuer;\n                this.handleUnsuccessfulValidation();\n                return toReturn;\n            }\n        } else {\n            this.loggerService.logWarning('authWellKnownEndpoints is undefined');\n            toReturn.state = ValidationResult.NoAuthWellKnownEndPoints;\n            this.handleUnsuccessfulValidation();\n            return toReturn;\n        }\n\n        if (!this.oidcSecurityValidation.validate_id_token_aud(toReturn.decoded_id_token, this.configurationProvider.openIDConfiguration.client_id)) {\n            this.loggerService.logWarning('authorizedCallback incorrect aud');\n            toReturn.state = ValidationResult.IncorrectAud;\n            this.handleUnsuccessfulValidation();\n            return toReturn;\n        }\n\n        if (!this.oidcSecurityValidation.validate_id_token_exp_not_expired(toReturn.decoded_id_token)) {\n            this.loggerService.logWarning('authorizedCallback token expired');\n            toReturn.state = ValidationResult.TokenExpired;\n            this.handleUnsuccessfulValidation();\n            return toReturn;\n        }\n\n        // flow id_token token\n        if (\n            this.configurationProvider.openIDConfiguration.response_type !== 'id_token token' &&\n            this.configurationProvider.openIDConfiguration.response_type !== 'code'\n        ) {\n            toReturn.authResponseIsValid = true;\n            toReturn.state = ValidationResult.Ok;\n            this.handleSuccessfulValidation();\n            this.handleUnsuccessfulValidation();\n            return toReturn;\n        }\n\n        if (\n            !this.oidcSecurityValidation.validate_id_token_at_hash(\n                toReturn.access_token,\n                toReturn.decoded_id_token.at_hash,\n                this.configurationProvider.openIDConfiguration.response_type === 'code'\n            ) ||\n            !toReturn.access_token\n        ) {\n            this.loggerService.logWarning('authorizedCallback incorrect at_hash');\n            toReturn.state = ValidationResult.IncorrectAtHash;\n            this.handleUnsuccessfulValidation();\n            return toReturn;\n        }\n\n        toReturn.authResponseIsValid = true;\n        toReturn.state = ValidationResult.Ok;\n        this.handleSuccessfulValidation();\n        return toReturn;\n    }\n\n    private handleSuccessfulValidation() {\n        this.oidcSecurityCommon.authNonce = '';\n\n        if (this.configurationProvider.openIDConfiguration.auto_clean_state_after_authentication) {\n            this.oidcSecurityCommon.authStateControl = '';\n        }\n        this.loggerService.logDebug('AuthorizedCallback token(s) validated, continue');\n    }\n\n    private handleUnsuccessfulValidation() {\n        this.oidcSecurityCommon.authNonce = '';\n\n        if (this.configurationProvider.openIDConfiguration.auto_clean_state_after_authentication) {\n            this.oidcSecurityCommon.authStateControl = '';\n        }\n        this.loggerService.logDebug('AuthorizedCallback token(s) invalid');\n    }\n}\n","import { Injectable, NgZone } from '@angular/core';\nimport { from, Observable, Observer, Subject } from 'rxjs';\nimport { take } from 'rxjs/operators';\nimport { ConfigurationProvider } from './auth-configuration.provider';\nimport { IFrameService } from './existing-iframe.service';\nimport { LoggerService } from './oidc.logger.service';\nimport { OidcSecurityCommon } from './oidc.security.common';\n\nconst IFRAME_FOR_CHECK_SESSION_IDENTIFIER = 'myiFrameForCheckSession';\n\n// http://openid.net/specs/openid-connect-session-1_0-ID4.html\n\n@Injectable()\nexport class OidcSecurityCheckSession {\n    private sessionIframe: any;\n    private iframeMessageEvent: any;\n    private scheduledHeartBeat: any;\n    private lastIFrameRefresh = 0;\n    private outstandingMessages = 0;\n    private heartBeatInterval = 3000;\n    private iframeRefreshInterval = 60000;\n    private _onCheckSessionChanged = new Subject<any>();\n\n    public get onCheckSessionChanged(): Observable<any> {\n        return this._onCheckSessionChanged.asObservable();\n    }\n\n    constructor(\n        private oidcSecurityCommon: OidcSecurityCommon,\n        private loggerService: LoggerService,\n        private iFrameService: IFrameService,\n        private zone: NgZone,\n        private readonly configurationProvider: ConfigurationProvider\n    ) {}\n\n    private doesSessionExist(): boolean {\n        const existingIFrame = this.iFrameService.getExistingIFrame(IFRAME_FOR_CHECK_SESSION_IDENTIFIER);\n\n        if (!existingIFrame) {\n            return false;\n        }\n\n        this.sessionIframe = existingIFrame;\n        return true;\n    }\n\n    private init() {\n        if (this.lastIFrameRefresh + this.iframeRefreshInterval > Date.now()) {\n            return from([this]);\n        }\n\n        if (!this.doesSessionExist()) {\n            this.sessionIframe = this.iFrameService.addIFrameToWindowBody(IFRAME_FOR_CHECK_SESSION_IDENTIFIER);\n            this.iframeMessageEvent = this.messageHandler.bind(this);\n            window.addEventListener('message', this.iframeMessageEvent, false);\n        }\n\n        if (!this.configurationProvider.wellKnownEndpoints) {\n            this.loggerService.logWarning('init check session: authWellKnownEndpoints is undefined. Returning.');\n            return;\n        }\n\n        if (this.configurationProvider.wellKnownEndpoints.check_session_iframe) {\n            this.sessionIframe.contentWindow.location.replace(this.configurationProvider.wellKnownEndpoints.check_session_iframe);\n        } else {\n            this.loggerService.logWarning('init check session: authWellKnownEndpoints is undefined');\n        }\n\n        return Observable.create((observer: Observer<OidcSecurityCheckSession>) => {\n            this.sessionIframe.onload = () => {\n                this.lastIFrameRefresh = Date.now();\n                observer.next(this);\n                observer.complete();\n            };\n        });\n    }\n\n    startCheckingSession(clientId: string): void {\n        if (this.scheduledHeartBeat) {\n            return;\n        }\n\n        this.pollServerSession(clientId);\n    }\n\n    stopCheckingSession(): void {\n        if (!this.scheduledHeartBeat) {\n            return;\n        }\n\n        this.clearScheduledHeartBeat();\n    }\n\n    private pollServerSession(clientId: string) {\n        const _pollServerSessionRecur = () => {\n            this.init()\n                .pipe(take(1))\n                .subscribe(() => {\n                    if (this.sessionIframe && clientId) {\n                        this.loggerService.logDebug(this.sessionIframe);\n                        const session_state = this.oidcSecurityCommon.sessionState;\n                        if (session_state) {\n                            this.outstandingMessages++;\n                            this.sessionIframe.contentWindow.postMessage(\n                                clientId + ' ' + session_state,\n                                this.configurationProvider.openIDConfiguration.stsServer\n                            );\n                        } else {\n                            this.loggerService.logDebug('OidcSecurityCheckSession pollServerSession session_state is blank');\n                            this._onCheckSessionChanged.next();\n                        }\n                    } else {\n                        this.loggerService.logWarning('OidcSecurityCheckSession pollServerSession sessionIframe does not exist');\n                        this.loggerService.logDebug(clientId);\n                        this.loggerService.logDebug(this.sessionIframe);\n                        // this.init();\n                    }\n\n                    // after sending three messages with no response, fail.\n                    if (this.outstandingMessages > 3) {\n                        this.loggerService.logError(\n                            `OidcSecurityCheckSession not receiving check session response messages. Outstanding messages: ${\n                                this.outstandingMessages\n                            }. Server unreachable?`\n                        );\n                        this._onCheckSessionChanged.next();\n                    }\n\n                    this.scheduledHeartBeat = setTimeout(_pollServerSessionRecur, this.heartBeatInterval);\n                });\n        };\n\n        this.outstandingMessages = 0;\n\n        this.zone.runOutsideAngular(() => {\n            this.scheduledHeartBeat = setTimeout(_pollServerSessionRecur, this.heartBeatInterval);\n        });\n    }\n    private clearScheduledHeartBeat() {\n        clearTimeout(this.scheduledHeartBeat);\n        this.scheduledHeartBeat = null;\n    }\n\n    private messageHandler(e: any) {\n        this.outstandingMessages = 0;\n        if (\n            this.sessionIframe &&\n            e.origin === this.configurationProvider.openIDConfiguration.stsServer &&\n            e.source === this.sessionIframe.contentWindow\n        ) {\n            if (e.data === 'error') {\n                this.loggerService.logWarning('error from checksession messageHandler');\n            } else if (e.data === 'changed') {\n                this._onCheckSessionChanged.next();\n            } else {\n                this.loggerService.logDebug(e.data + ' from checksession messageHandler');\n            }\n        }\n    }\n}\n","import { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Observable, of, ReplaySubject } from 'rxjs';\nimport { catchError, switchMap } from 'rxjs/operators';\n\nexport interface ConfigResult {\n    authWellknownEndpoints: any;\n    customConfig: any;\n}\n\n@Injectable()\nexport class OidcConfigService {\n    private configurationLoadedInternal = new ReplaySubject<ConfigResult>(1);\n\n    public get onConfigurationLoaded(): Observable<ConfigResult> {\n        return this.configurationLoadedInternal.asObservable();\n    }\n\n    constructor(private readonly httpClient: HttpClient) { }\n\n    load(configUrl: string) {\n        return this.httpClient\n            .get(configUrl)\n            .pipe(\n                switchMap(clientConfiguration => {\n                    return this.loadUsingConfiguration(clientConfiguration);\n                }),\n                catchError(error => {\n                    console.error(`OidcConfigService 'load' threw an error on calling ${configUrl}`, error);\n                    this.configurationLoadedInternal.next(undefined);\n                    return of(false);\n                })\n            )\n            .toPromise();\n    }\n\n    load_using_stsServer(stsServer: string) {\n        return this.loadUsingConfiguration({ stsServer }).toPromise();\n    }\n\n    load_using_custom_stsServer(url: string) {\n        return this.httpClient\n            .get(url)\n            .pipe(\n                switchMap(wellKnownEndpoints => {\n                    this.configurationLoadedInternal.next({\n                        authWellknownEndpoints: wellKnownEndpoints,\n                        customConfig: { stsServer: url },\n                    });\n                    return of(true);\n                }),\n                catchError(error => {\n                    console.error(`OidcConfigService 'load_using_custom_stsServer' threw an error on calling ${url}`, error);\n                    this.configurationLoadedInternal.next(undefined);\n                    return of(false);\n                })\n            )\n            .toPromise();\n    }\n\n    private loadUsingConfiguration(clientConfig: any) {\n        if (!clientConfig.stsServer) {\n            console.error(`Property 'stsServer' is not present of passed config ${JSON.stringify(clientConfig)}`, clientConfig);\n            throw new Error(`Property 'stsServer' is not present of passed config ${JSON.stringify(clientConfig)}`);\n        }\n\n        const url = `${clientConfig.stsServer}/.well-known/openid-configuration`;\n\n        return this.httpClient.get(url).pipe(\n            switchMap(wellKnownEndpoints => {\n                this.configurationLoadedInternal.next({\n                    authWellknownEndpoints: wellKnownEndpoints,\n                    customConfig: clientConfig,\n                });\n                return of(true);\n            }),\n            catchError(error => {\n                console.error(`OidcConfigService 'load_using_stsServer' threw an error on calling ${url}`, error);\n                this.configurationLoadedInternal.next(undefined);\n                return of(false);\n            })\n        );\n    }\n}\n","import { Injectable } from '@angular/core';\nimport { Observable, Observer } from 'rxjs';\nimport { IFrameService } from './existing-iframe.service';\nimport { LoggerService } from './oidc.logger.service';\n\nconst IFRAME_FOR_SILENT_RENEW_IDENTIFIER = 'myiFrameForSilentRenew';\n\n@Injectable()\nexport class OidcSecuritySilentRenew {\n    private sessionIframe: any;\n    private isRenewInitialized = false;\n\n    constructor(private loggerService: LoggerService, private iFrameService: IFrameService) {}\n\n    initRenew() {\n        const existingIFrame = this.iFrameService.getExistingIFrame(IFRAME_FOR_SILENT_RENEW_IDENTIFIER);\n\n        if (!existingIFrame) {\n            this.iFrameService.addIFrameToWindowBody(IFRAME_FOR_SILENT_RENEW_IDENTIFIER);\n        }\n\n        this.isRenewInitialized = true;\n    }\n\n    startRenew(url: string): Observable<any> {\n        if (!this.isRenewInitialized) {\n            this.initRenew();\n        }\n\n        this.sessionIframe = this.iFrameService.getExistingIFrame(IFRAME_FOR_SILENT_RENEW_IDENTIFIER);\n\n        this.loggerService.logDebug('startRenew for URL:' + url);\n        this.sessionIframe.contentWindow.location.replace(url);\n\n        return Observable.create((observer: Observer<any>) => {\n            this.sessionIframe.onload = () => {\n                observer.next(this);\n                observer.complete();\n            };\n        });\n    }\n}\n","import { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { OidcDataService } from '../data-services/oidc-data.service';\nimport { ConfigurationProvider } from './auth-configuration.provider';\nimport { LoggerService } from './oidc.logger.service';\nimport { OidcSecurityCommon } from './oidc.security.common';\n\n@Injectable()\nexport class OidcSecurityUserService {\n    private userData: any = '';\n\n    constructor(\n        private oidcDataService: OidcDataService,\n        private oidcSecurityCommon: OidcSecurityCommon,\n        private loggerService: LoggerService,\n        private readonly configurationProvider: ConfigurationProvider\n    ) {}\n\n    initUserData() {\n        return this.getIdentityUserData().pipe(map((data: any) => (this.userData = data)));\n    }\n\n    getUserData(): any {\n        if (!this.userData) {\n            throw Error('UserData is not set!');\n        }\n\n        return this.userData;\n    }\n\n    setUserData(value: any): void {\n        this.userData = value;\n    }\n\n    private getIdentityUserData(): Observable<any> {\n        const token = this.oidcSecurityCommon.getAccessToken();\n\n        if (!this.configurationProvider.wellKnownEndpoints) {\n            this.loggerService.logWarning('init check session: authWellKnownEndpoints is undefined');\n\n            throw Error('authWellKnownEndpoints is undefined');\n        }\n\n        const canGetUserData =\n            this.configurationProvider.wellKnownEndpoints && this.configurationProvider.wellKnownEndpoints.userinfo_endpoint;\n\n        if (!canGetUserData) {\n            this.loggerService.logError(\n                'init check session: authWellKnownEndpoints.userinfo_endpoint is undefined; set auto_userinfo = false in config'\n            );\n            throw Error('authWellKnownEndpoints.userinfo_endpoint is undefined');\n        }\n\n        return this.oidcDataService.getIdentityUserData(this.configurationProvider.wellKnownEndpoints.userinfo_endpoint || '', token);\n    }\n}\n","import { HttpParameterCodec } from '@angular/common/http';\n\nexport class UriEncoder implements HttpParameterCodec {\n    encodeKey(key: string): string {\n        return encodeURIComponent(key);\n    }\n\n    encodeValue(value: string): string {\n        return encodeURIComponent(value);\n    }\n\n    decodeKey(key: string): string {\n        return decodeURIComponent(key);\n    }\n\n    decodeValue(value: string): string {\n        return decodeURIComponent(value);\n    }\n}\n","import { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';\nimport { Injectable, NgZone } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { BehaviorSubject, from, Observable, of, Subject, throwError as observableThrowError, timer } from 'rxjs';\nimport { catchError, filter, map, race, shareReplay, switchMap, switchMapTo, take, tap } from 'rxjs/operators';\nimport { OidcDataService } from '../data-services/oidc-data.service';\nimport { OpenIdConfiguration } from '../models/auth.configuration';\nimport { AuthWellKnownEndpoints } from '../models/auth.well-known-endpoints';\nimport { AuthorizationResult } from '../models/authorization-result';\nimport { AuthorizationState } from '../models/authorization-state.enum';\nimport { JwtKeys } from '../models/jwtkeys';\nimport { ValidateStateResult } from '../models/validate-state-result.model';\nimport { ValidationResult } from '../models/validation-result.enum';\nimport { ConfigurationProvider } from './auth-configuration.provider';\nimport { StateValidationService } from './oidc-security-state-validation.service';\nimport { TokenHelperService } from './oidc-token-helper.service';\nimport { LoggerService } from './oidc.logger.service';\nimport { OidcSecurityCheckSession } from './oidc.security.check-session';\nimport { OidcSecurityCommon } from './oidc.security.common';\nimport { OidcSecuritySilentRenew } from './oidc.security.silent-renew';\nimport { OidcSecurityUserService } from './oidc.security.user-service';\nimport { OidcSecurityValidation } from './oidc.security.validation';\nimport { UriEncoder } from './uri-encoder';\n\n@Injectable()\nexport class OidcSecurityService {\n    private _onModuleSetup = new Subject<boolean>();\n    private _onCheckSessionChanged = new Subject<boolean>();\n    private _onAuthorizationResult = new Subject<AuthorizationResult>();\n\n    public get onModuleSetup(): Observable<boolean> {\n        return this._onModuleSetup.asObservable();\n    }\n\n    public get onAuthorizationResult(): Observable<AuthorizationResult> {\n        return this._onAuthorizationResult.asObservable();\n    }\n\n    public get onCheckSessionChanged(): Observable<boolean> {\n        return this._onCheckSessionChanged.asObservable();\n    }\n\n    public get onConfigurationChange(): Observable<OpenIdConfiguration> {\n        return this.configurationProvider.onConfigurationChange;\n    }\n\n    checkSessionChanged = false;\n    moduleSetup = false;\n\n    private _isModuleSetup = new BehaviorSubject<boolean>(false);\n\n    private _isAuthorized = new BehaviorSubject<boolean>(false);\n    private _isSetupAndAuthorized: Observable<boolean>;\n\n    private _userData = new BehaviorSubject<any>('');\n    private authWellKnownEndpointsLoaded = false;\n    private runTokenValidationRunning = false;\n    private _scheduledHeartBeat: any;\n    private boundSilentRenewEvent: any;\n\n    constructor(\n        private oidcDataService: OidcDataService,\n        private stateValidationService: StateValidationService,\n        private router: Router,\n        private oidcSecurityCheckSession: OidcSecurityCheckSession,\n        private oidcSecuritySilentRenew: OidcSecuritySilentRenew,\n        private oidcSecurityUserService: OidcSecurityUserService,\n        private oidcSecurityCommon: OidcSecurityCommon,\n        private oidcSecurityValidation: OidcSecurityValidation,\n        private tokenHelperService: TokenHelperService,\n        private loggerService: LoggerService,\n        private zone: NgZone,\n        private readonly httpClient: HttpClient,\n        private readonly configurationProvider: ConfigurationProvider\n    ) {\n        this.onModuleSetup.pipe(take(1)).subscribe(() => {\n            this.moduleSetup = true;\n            this._isModuleSetup.next(true);\n        });\n\n        this._isSetupAndAuthorized = this._isModuleSetup.pipe(\n            filter((isModuleSetup: boolean) => isModuleSetup),\n            switchMap(() => {\n                if (!this.configurationProvider.openIDConfiguration.silent_renew) {\n                    this.loggerService.logDebug(`IsAuthorizedRace: Silent Renew Not Active. Emitting.`);\n                    return from([true]);\n                }\n\n                const race$ = this._isAuthorized.asObservable().pipe(\n                    filter((isAuthorized: boolean) => isAuthorized),\n                    take(1),\n                    tap(() => this.loggerService.logDebug('IsAuthorizedRace: Existing token is still authorized.')),\n                    race(\n                        this._onAuthorizationResult.pipe(\n                            take(1),\n                            tap(() => this.loggerService.logDebug('IsAuthorizedRace: Silent Renew Refresh Session Complete')),\n                            map(() => true)\n                        ),\n                        timer(5000).pipe(\n                            // backup, if nothing happens after 5 seconds stop waiting and emit\n                            tap(() => {\n                                this.resetAuthorizationData(false);\n                                this.oidcSecurityCommon.authNonce = '';\n                                this.loggerService.logWarning('IsAuthorizedRace: Timeout reached. Emitting.');\n                            }),\n                            map(() => true)\n                        )\n                    )\n                );\n\n                this.loggerService.logDebug('Silent Renew is active, check if token in storage is active');\n                if (this.oidcSecurityCommon.authNonce === '' || this.oidcSecurityCommon.authNonce === undefined) {\n                    // login not running, or a second silent renew, user must login first before this will work.\n                    this.loggerService.logDebug('Silent Renew or login not running, try to refresh the session');\n                    this.refreshSession();\n                }\n\n                return race$;\n            }),\n            tap(() => this.loggerService.logDebug('IsAuthorizedRace: Completed')),\n            switchMapTo(this._isAuthorized.asObservable()),\n            tap((isAuthorized: boolean) => this.loggerService.logDebug(`getIsAuthorized: ${isAuthorized}`)),\n            shareReplay(1)\n        );\n\n        this._isSetupAndAuthorized\n            .pipe(filter(() => this.configurationProvider.openIDConfiguration.start_checksession))\n            .subscribe(isSetupAndAuthorized => {\n                if (isSetupAndAuthorized) {\n                    this.oidcSecurityCheckSession.startCheckingSession(this.configurationProvider.openIDConfiguration.client_id);\n                } else {\n                    this.oidcSecurityCheckSession.stopCheckingSession();\n                }\n            });\n    }\n\n    setupModule(openIdConfiguration: OpenIdConfiguration, authWellKnownEndpoints: AuthWellKnownEndpoints): void {\n        this.configurationProvider.setup(openIdConfiguration, authWellKnownEndpoints);\n\n        this.oidcSecurityCheckSession.onCheckSessionChanged.subscribe(() => {\n            this.loggerService.logDebug('onCheckSessionChanged');\n            this.checkSessionChanged = true;\n            this._onCheckSessionChanged.next(this.checkSessionChanged);\n        });\n\n        const userData = this.oidcSecurityCommon.userData;\n        if (userData) {\n            this.setUserData(userData);\n        }\n\n        const isAuthorized = this.oidcSecurityCommon.isAuthorized;\n        if (isAuthorized) {\n            this.loggerService.logDebug('IsAuthorized setup module');\n            this.loggerService.logDebug(this.oidcSecurityCommon.idToken);\n            if (\n                this.oidcSecurityValidation.isTokenExpired(\n                    this.oidcSecurityCommon.idToken,\n                    this.configurationProvider.openIDConfiguration.silent_renew_offset_in_seconds\n                )\n            ) {\n                this.loggerService.logDebug('IsAuthorized setup module; id_token isTokenExpired');\n            } else {\n                this.loggerService.logDebug('IsAuthorized setup module; id_token is valid');\n                this.setIsAuthorized(isAuthorized);\n            }\n            this.runTokenValidation();\n        }\n\n        this.loggerService.logDebug('STS server: ' + this.configurationProvider.openIDConfiguration.stsServer);\n\n        this._onModuleSetup.next();\n\n        if (this.configurationProvider.openIDConfiguration.silent_renew) {\n            this.oidcSecuritySilentRenew.initRenew();\n\n            // Support authorization via DOM events.\n            // Deregister if OidcSecurityService.setupModule is called again by any instance.\n            //      We only ever want the latest setup service to be reacting to this event.\n            this.boundSilentRenewEvent = this.silentRenewEventHandler.bind(this);\n\n            const instanceId = Math.random();\n\n            const boundSilentRenewInitEvent: any = ((e: CustomEvent) => {\n                if (e.detail !== instanceId) {\n                    window.removeEventListener('oidc-silent-renew-message', this.boundSilentRenewEvent);\n                    window.removeEventListener('oidc-silent-renew-init', boundSilentRenewInitEvent);\n                }\n            }).bind(this);\n\n            window.addEventListener('oidc-silent-renew-init', boundSilentRenewInitEvent, false);\n            window.addEventListener('oidc-silent-renew-message', this.boundSilentRenewEvent, false);\n\n            window.dispatchEvent(\n                new CustomEvent('oidc-silent-renew-init', {\n                    detail: instanceId,\n                })\n            );\n        }\n    }\n\n    getUserData(): Observable<any> {\n        return this._userData.asObservable();\n    }\n\n    getIsModuleSetup(): Observable<boolean> {\n        return this._isModuleSetup.asObservable();\n    }\n\n    getIsAuthorized(): Observable<boolean> {\n        return this._isSetupAndAuthorized;\n    }\n\n    getToken(): string {\n        if (!this._isAuthorized.getValue()) {\n            return '';\n        }\n\n        const token = this.oidcSecurityCommon.getAccessToken();\n        return decodeURIComponent(token);\n    }\n\n    getIdToken(): string {\n        if (!this._isAuthorized.getValue()) {\n            return '';\n        }\n\n        const token = this.oidcSecurityCommon.getIdToken();\n        return decodeURIComponent(token);\n    }\n\n    getPayloadFromIdToken(encode = false): any {\n        const token = this.getIdToken();\n        return this.tokenHelperService.getPayloadFromToken(token, encode);\n    }\n\n    setState(state: string): void {\n        this.oidcSecurityCommon.authStateControl = state;\n    }\n\n    getState(): string {\n        return this.oidcSecurityCommon.authStateControl;\n    }\n\n    setCustomRequestParameters(params: { [key: string]: string | number | boolean }) {\n        this.oidcSecurityCommon.customRequestParams = params;\n    }\n\n    // Code Flow with PCKE or Implicit Flow\n    authorize(urlHandler?: (url: string) => any) {\n        if (this.configurationProvider.wellKnownEndpoints) {\n            this.authWellKnownEndpointsLoaded = true;\n        }\n\n        if (!this.authWellKnownEndpointsLoaded) {\n            this.loggerService.logError('Well known endpoints must be loaded before user can login!');\n            return;\n        }\n\n        if (!this.oidcSecurityValidation.config_validate_response_type(this.configurationProvider.openIDConfiguration.response_type)) {\n            // invalid response_type\n            return;\n        }\n\n        this.resetAuthorizationData(false);\n\n        this.loggerService.logDebug('BEGIN Authorize Code Flow, no auth data');\n\n        let state = this.oidcSecurityCommon.authStateControl;\n        if (!state) {\n            state = Date.now() + '' + Math.random() + Math.random();\n            this.oidcSecurityCommon.authStateControl = state;\n        }\n\n        const nonce = 'N' + Math.random() + '' + Date.now();\n        this.oidcSecurityCommon.authNonce = nonce;\n        this.loggerService.logDebug('AuthorizedController created. local state: ' + this.oidcSecurityCommon.authStateControl);\n\n        let url = '';\n        // Code Flow\n        if (this.configurationProvider.openIDConfiguration.response_type === 'code') {\n            // code_challenge with \"S256\"\n            const code_verifier = 'C' + Math.random() + '' + Date.now() + '' + Date.now() + Math.random();\n            const code_challenge = this.oidcSecurityValidation.generate_code_verifier(code_verifier);\n\n            this.oidcSecurityCommon.code_verifier = code_verifier;\n\n            if (this.configurationProvider.wellKnownEndpoints) {\n                url = this.createAuthorizeUrl(\n                    true,\n                    code_challenge,\n                    this.configurationProvider.openIDConfiguration.redirect_url,\n                    nonce,\n                    state,\n                    this.configurationProvider.wellKnownEndpoints.authorization_endpoint || ''\n                );\n            } else {\n                this.loggerService.logError('authWellKnownEndpoints is undefined');\n            }\n        } else {\n            // Implicit Flow\n\n            if (this.configurationProvider.wellKnownEndpoints) {\n                url = this.createAuthorizeUrl(\n                    false,\n                    '',\n                    this.configurationProvider.openIDConfiguration.redirect_url,\n                    nonce,\n                    state,\n                    this.configurationProvider.wellKnownEndpoints.authorization_endpoint || ''\n                );\n            } else {\n                this.loggerService.logError('authWellKnownEndpoints is undefined');\n            }\n        }\n\n        if (urlHandler) {\n            urlHandler(url);\n        } else {\n            this.redirectTo(url);\n        }\n    }\n\n    // Code Flow\n    authorizedCallbackWithCode(urlToCheck: string) {\n        const urlParts = urlToCheck.split('?');\n        const params = new HttpParams({\n            fromString: urlParts[1],\n        });\n        const code = params.get('code');\n        const state = params.get('state');\n        const session_state = params.get('session_state');\n\n        if (code && state) {\n            this.requestTokensWithCode(code, state, session_state);\n        }\n    }\n\n    // Code Flow\n    requestTokensWithCode(code: string, state: string, session_state: string | null) {\n        this._isModuleSetup\n            .pipe(\n                filter((isModuleSetup: boolean) => isModuleSetup),\n                take(1)\n            )\n            .subscribe(() => {\n                this.requestTokensWithCodeProcedure(code, state, session_state);\n            });\n    }\n\n    // Code Flow with PCKE\n    requestTokensWithCodeProcedure(code: string, state: string, session_state: string | null) {\n        let tokenRequestUrl = '';\n        if (this.configurationProvider.wellKnownEndpoints && this.configurationProvider.wellKnownEndpoints.token_endpoint) {\n            tokenRequestUrl = `${this.configurationProvider.wellKnownEndpoints.token_endpoint}`;\n        }\n\n        if (!this.oidcSecurityValidation.validateStateFromHashCallback(state, this.oidcSecurityCommon.authStateControl)) {\n            this.loggerService.logWarning('authorizedCallback incorrect state');\n            // ValidationResult.StatesDoNotMatch;\n            return;\n        }\n\n        let headers: HttpHeaders = new HttpHeaders();\n        headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n\n        let data =\n            `grant_type=authorization_code&client_id=${this.configurationProvider.openIDConfiguration.client_id}` +\n            `&code_verifier=${this.oidcSecurityCommon.code_verifier}&code=${code}&redirect_uri=${\n                this.configurationProvider.openIDConfiguration.redirect_url\n            }`;\n        if (this.oidcSecurityCommon.silentRenewRunning === 'running') {\n            data =\n                `grant_type=authorization_code&client_id=${this.configurationProvider.openIDConfiguration.client_id}` +\n                `&code_verifier=${this.oidcSecurityCommon.code_verifier}&code=${code}&redirect_uri=${\n                    this.configurationProvider.openIDConfiguration.silent_renew_url\n                }`;\n        }\n\n        this.httpClient\n            .post(tokenRequestUrl, data, { headers: headers })\n            .pipe(\n                map(response => {\n                    let obj: any = new Object();\n                    obj = response;\n                    obj.state = state;\n                    obj.session_state = session_state;\n\n                    this.authorizedCodeFlowCallbackProcedure(obj);\n                }),\n                catchError(error => {\n                    this.loggerService.logError(error);\n                    this.loggerService.logError(`OidcService code request ${this.configurationProvider.openIDConfiguration.stsServer}`);\n                    return of(false);\n                })\n            )\n            .subscribe();\n    }\n\n    // Code Flow\n    private authorizedCodeFlowCallbackProcedure(result: any) {\n        const silentRenew = this.oidcSecurityCommon.silentRenewRunning;\n        const isRenewProcess = silentRenew === 'running';\n\n        this.loggerService.logDebug('BEGIN authorized Code Flow Callback, no auth data');\n        this.resetAuthorizationData(isRenewProcess);\n        this.authorizedCallbackProcedure(result, isRenewProcess);\n    }\n\n    // Implicit Flow\n    private authorizedImplicitFlowCallbackProcedure(hash?: string) {\n        const silentRenew = this.oidcSecurityCommon.silentRenewRunning;\n        const isRenewProcess = silentRenew === 'running';\n\n        this.loggerService.logDebug('BEGIN authorizedCallback, no auth data');\n        this.resetAuthorizationData(isRenewProcess);\n\n        hash = hash || window.location.hash.substr(1);\n\n        const result: any = hash.split('&').reduce(function(resultData: any, item: string) {\n            const parts = item.split('=');\n            resultData[<string>parts.shift()] = parts.join('=');\n            return resultData;\n        }, {});\n        this.authorizedCallbackProcedure(result, isRenewProcess);\n    }\n\n    // Implicit Flow\n    authorizedImplicitFlowCallback(hash?: string) {\n        this._isModuleSetup\n            .pipe(\n                filter((isModuleSetup: boolean) => isModuleSetup),\n                take(1)\n            )\n            .subscribe(() => {\n                this.authorizedImplicitFlowCallbackProcedure(hash);\n            });\n    }\n\n    private redirectTo(url: string) {\n        window.location.href = url;\n    }\n\n    // Implicit Flow\n    private authorizedCallbackProcedure(result: any, isRenewProcess: boolean) {\n        this.oidcSecurityCommon.authResult = result;\n\n        if (!this.configurationProvider.openIDConfiguration.history_cleanup_off && !isRenewProcess) {\n            // reset the history to remove the tokens\n            window.history.replaceState({}, window.document.title, window.location.origin + window.location.pathname);\n        } else {\n            this.loggerService.logDebug('history clean up inactive');\n        }\n\n        if (result.error) {\n            if (isRenewProcess) {\n                this.loggerService.logDebug(result);\n            } else {\n                this.loggerService.logWarning(result);\n            }\n\n            if ((result.error as string) === 'login_required') {\n                this._onAuthorizationResult.next(new AuthorizationResult(AuthorizationState.unauthorized, ValidationResult.LoginRequired));\n            } else {\n                this._onAuthorizationResult.next(new AuthorizationResult(AuthorizationState.unauthorized, ValidationResult.SecureTokenServerError));\n            }\n\n            this.resetAuthorizationData(false);\n            this.oidcSecurityCommon.authNonce = '';\n\n            if (!this.configurationProvider.openIDConfiguration.trigger_authorization_result_event && !isRenewProcess) {\n                this.router.navigate([this.configurationProvider.openIDConfiguration.unauthorized_route]);\n            }\n        } else {\n            this.loggerService.logDebug(result);\n\n            this.loggerService.logDebug('authorizedCallback created, begin token validation');\n\n            this.getSigningKeys().subscribe(\n                jwtKeys => {\n                    const validationResult = this.getValidatedStateResult(result, jwtKeys);\n\n                    if (validationResult.authResponseIsValid) {\n                        this.setAuthorizationData(validationResult.access_token, validationResult.id_token);\n                        this.oidcSecurityCommon.silentRenewRunning = '';\n\n                        if (this.configurationProvider.openIDConfiguration.auto_userinfo) {\n                            this.getUserinfo(isRenewProcess, result, validationResult.id_token, validationResult.decoded_id_token).subscribe(\n                                response => {\n                                    if (response) {\n                                        this._onAuthorizationResult.next(\n                                            new AuthorizationResult(AuthorizationState.authorized, validationResult.state)\n                                        );\n                                        if (!this.configurationProvider.openIDConfiguration.trigger_authorization_result_event && !isRenewProcess) {\n                                            this.router.navigate([this.configurationProvider.openIDConfiguration.post_login_route]);\n                                        }\n                                    } else {\n                                        this._onAuthorizationResult.next(\n                                            new AuthorizationResult(AuthorizationState.unauthorized, validationResult.state)\n                                        );\n                                        if (!this.configurationProvider.openIDConfiguration.trigger_authorization_result_event && !isRenewProcess) {\n                                            this.router.navigate([this.configurationProvider.openIDConfiguration.unauthorized_route]);\n                                        }\n                                    }\n                                },\n                                err => {\n                                    /* Something went wrong while getting signing key */\n                                    this.loggerService.logWarning('Failed to retreive user info with error: ' + JSON.stringify(err));\n                                }\n                            );\n                        } else {\n                            if (!isRenewProcess) {\n                                // userData is set to the id_token decoded, auto get user data set to false\n                                this.oidcSecurityUserService.setUserData(validationResult.decoded_id_token);\n                                this.setUserData(this.oidcSecurityUserService.getUserData());\n                            }\n\n                            this.runTokenValidation();\n\n                            this._onAuthorizationResult.next(new AuthorizationResult(AuthorizationState.authorized, validationResult.state));\n                            if (!this.configurationProvider.openIDConfiguration.trigger_authorization_result_event && !isRenewProcess) {\n                                this.router.navigate([this.configurationProvider.openIDConfiguration.post_login_route]);\n                            }\n                        }\n                    } else {\n                        // something went wrong\n                        this.loggerService.logWarning('authorizedCallback, token(s) validation failed, resetting');\n                        this.loggerService.logWarning(window.location.hash);\n                        this.resetAuthorizationData(false);\n                        this.oidcSecurityCommon.silentRenewRunning = '';\n\n                        this._onAuthorizationResult.next(new AuthorizationResult(AuthorizationState.unauthorized, validationResult.state));\n                        if (!this.configurationProvider.openIDConfiguration.trigger_authorization_result_event && !isRenewProcess) {\n                            this.router.navigate([this.configurationProvider.openIDConfiguration.unauthorized_route]);\n                        }\n                    }\n                },\n                err => {\n                    /* Something went wrong while getting signing key */\n                    this.loggerService.logWarning('Failed to retreive siging key with error: ' + JSON.stringify(err));\n                    this.oidcSecurityCommon.silentRenewRunning = '';\n                }\n            );\n        }\n    }\n\n    getUserinfo(isRenewProcess = false, result?: any, id_token?: any, decoded_id_token?: any): Observable<boolean> {\n        result = result ? result : this.oidcSecurityCommon.authResult;\n        id_token = id_token ? id_token : this.oidcSecurityCommon.idToken;\n        decoded_id_token = decoded_id_token ? decoded_id_token : this.tokenHelperService.getPayloadFromToken(id_token, false);\n\n        return new Observable<boolean>(observer => {\n            // flow id_token token\n            if (\n                this.configurationProvider.openIDConfiguration.response_type === 'id_token token' ||\n                this.configurationProvider.openIDConfiguration.response_type === 'code'\n            ) {\n                if (isRenewProcess && this._userData.value) {\n                    this.oidcSecurityCommon.sessionState = result.session_state;\n                    observer.next(true);\n                    observer.complete();\n                } else {\n                    this.oidcSecurityUserService.initUserData().subscribe(() => {\n                        this.loggerService.logDebug('authorizedCallback (id_token token || code) flow');\n\n                        const userData = this.oidcSecurityUserService.getUserData();\n\n                        if (this.oidcSecurityValidation.validate_userdata_sub_id_token(decoded_id_token.sub, userData.sub)) {\n                            this.setUserData(userData);\n                            this.loggerService.logDebug(this.oidcSecurityCommon.accessToken);\n                            this.loggerService.logDebug(this.oidcSecurityUserService.getUserData());\n\n                            this.oidcSecurityCommon.sessionState = result.session_state;\n\n                            this.runTokenValidation();\n                            observer.next(true);\n                        } else {\n                            // something went wrong, userdata sub does not match that from id_token\n                            this.loggerService.logWarning('authorizedCallback, User data sub does not match sub in id_token');\n                            this.loggerService.logDebug('authorizedCallback, token(s) validation failed, resetting');\n                            this.resetAuthorizationData(false);\n                            observer.next(false);\n                        }\n                        observer.complete();\n                    });\n                }\n            } else {\n                // flow id_token\n                this.loggerService.logDebug('authorizedCallback id_token flow');\n                this.loggerService.logDebug(this.oidcSecurityCommon.accessToken);\n\n                // userData is set to the id_token decoded. No access_token.\n                this.oidcSecurityUserService.setUserData(decoded_id_token);\n                this.setUserData(this.oidcSecurityUserService.getUserData());\n\n                this.oidcSecurityCommon.sessionState = result.session_state;\n\n                this.runTokenValidation();\n\n                observer.next(true);\n                observer.complete();\n            }\n        });\n    }\n\n    logoff(urlHandler?: (url: string) => any) {\n        // /connect/endsession?id_token_hint=...&post_logout_redirect_uri=https://myapp.com\n        this.loggerService.logDebug('BEGIN Authorize, no auth data');\n\n        if (this.configurationProvider.wellKnownEndpoints) {\n            if (this.configurationProvider.wellKnownEndpoints.end_session_endpoint) {\n                const end_session_endpoint = this.configurationProvider.wellKnownEndpoints.end_session_endpoint;\n                const id_token_hint = this.oidcSecurityCommon.idToken;\n                const url = this.createEndSessionUrl(end_session_endpoint, id_token_hint);\n\n                this.resetAuthorizationData(false);\n\n                if (this.configurationProvider.openIDConfiguration.start_checksession && this.checkSessionChanged) {\n                    this.loggerService.logDebug('only local login cleaned up, server session has changed');\n                } else if (urlHandler) {\n                    urlHandler(url);\n                } else {\n                    this.redirectTo(url);\n                }\n            } else {\n                this.resetAuthorizationData(false);\n                this.loggerService.logDebug('only local login cleaned up, no end_session_endpoint');\n            }\n        } else {\n            this.loggerService.logWarning('authWellKnownEndpoints is undefined');\n        }\n    }\n\n    refreshSession(): Observable<any> {\n        if (!this.configurationProvider.openIDConfiguration.silent_renew) {\n            return from([false]);\n        }\n\n        this.loggerService.logDebug('BEGIN refresh session Authorize');\n\n        let state = this.oidcSecurityCommon.authStateControl;\n        if (state === '' || state === null) {\n            state = Date.now() + '' + Math.random() + Math.random();\n            this.oidcSecurityCommon.authStateControl = state;\n        }\n\n        const nonce = 'N' + Math.random() + '' + Date.now();\n        this.oidcSecurityCommon.authNonce = nonce;\n        this.loggerService.logDebug('RefreshSession created. adding myautostate: ' + this.oidcSecurityCommon.authStateControl);\n\n        let url = '';\n\n        // Code Flow\n        if (this.configurationProvider.openIDConfiguration.response_type === 'code') {\n            // code_challenge with \"S256\"\n            const code_verifier = 'C' + Math.random() + '' + Date.now() + '' + Date.now() + Math.random();\n            const code_challenge = this.oidcSecurityValidation.generate_code_verifier(code_verifier);\n\n            this.oidcSecurityCommon.code_verifier = code_verifier;\n\n            if (this.configurationProvider.wellKnownEndpoints) {\n                url = this.createAuthorizeUrl(\n                    true,\n                    code_challenge,\n                    this.configurationProvider.openIDConfiguration.silent_renew_url,\n                    nonce,\n                    state,\n                    this.configurationProvider.wellKnownEndpoints.authorization_endpoint || '',\n                    'none'\n                );\n            } else {\n                this.loggerService.logWarning('authWellKnownEndpoints is undefined');\n            }\n        } else {\n            if (this.configurationProvider.wellKnownEndpoints) {\n                url = this.createAuthorizeUrl(\n                    false,\n                    '',\n                    this.configurationProvider.openIDConfiguration.silent_renew_url,\n                    nonce,\n                    state,\n                    this.configurationProvider.wellKnownEndpoints.authorization_endpoint || '',\n                    'none'\n                );\n            } else {\n                this.loggerService.logWarning('authWellKnownEndpoints is undefined');\n            }\n        }\n\n        this.oidcSecurityCommon.silentRenewRunning = 'running';\n        return this.oidcSecuritySilentRenew.startRenew(url);\n    }\n\n    handleError(error: any) {\n        this.loggerService.logError(error);\n        if (error.status === 403 || error.status === '403') {\n            if (this.configurationProvider.openIDConfiguration.trigger_authorization_result_event) {\n                this._onAuthorizationResult.next(new AuthorizationResult(AuthorizationState.unauthorized, ValidationResult.NotSet));\n            } else {\n                this.router.navigate([this.configurationProvider.openIDConfiguration.forbidden_route]);\n            }\n        } else if (error.status === 401 || error.status === '401') {\n            const silentRenew = this.oidcSecurityCommon.silentRenewRunning;\n\n            this.resetAuthorizationData(!!silentRenew);\n\n            if (this.configurationProvider.openIDConfiguration.trigger_authorization_result_event) {\n                this._onAuthorizationResult.next(new AuthorizationResult(AuthorizationState.unauthorized, ValidationResult.NotSet));\n            } else {\n                this.router.navigate([this.configurationProvider.openIDConfiguration.unauthorized_route]);\n            }\n        }\n    }\n\n    startCheckingSilentRenew(): void {\n        this.runTokenValidation();\n    }\n\n    stopCheckingSilentRenew(): void {\n        if (this._scheduledHeartBeat) {\n            clearTimeout(this._scheduledHeartBeat);\n            this._scheduledHeartBeat = null;\n            this.runTokenValidationRunning = false;\n        }\n    }\n\n    resetAuthorizationData(isRenewProcess: boolean): void {\n        if (!isRenewProcess) {\n            if (this.configurationProvider.openIDConfiguration.auto_userinfo) {\n                // Clear user data. Fixes #97.\n                this.setUserData('');\n            }\n\n            this.oidcSecurityCommon.resetStorageData(isRenewProcess);\n            this.checkSessionChanged = false;\n            this.setIsAuthorized(false);\n        }\n    }\n\n    getEndSessionUrl(): string | undefined {\n        if (this.configurationProvider.wellKnownEndpoints) {\n            if (this.configurationProvider.wellKnownEndpoints.end_session_endpoint) {\n                const end_session_endpoint = this.configurationProvider.wellKnownEndpoints.end_session_endpoint;\n                const id_token_hint = this.oidcSecurityCommon.idToken;\n                return this.createEndSessionUrl(end_session_endpoint, id_token_hint);\n            }\n        }\n    }\n\n    private getValidatedStateResult(result: any, jwtKeys: JwtKeys): ValidateStateResult {\n        if (result.error) {\n            return new ValidateStateResult('', '', false, {});\n        }\n\n        return this.stateValidationService.validateState(result, jwtKeys);\n    }\n\n    private setUserData(userData: any): void {\n        this.oidcSecurityCommon.userData = userData;\n        this._userData.next(userData);\n    }\n\n    private setIsAuthorized(isAuthorized: boolean): void {\n        this._isAuthorized.next(isAuthorized);\n    }\n\n    private setAuthorizationData(access_token: any, id_token: any) {\n        if (this.oidcSecurityCommon.accessToken !== '') {\n            this.oidcSecurityCommon.accessToken = '';\n        }\n\n        this.loggerService.logDebug(access_token);\n        this.loggerService.logDebug(id_token);\n        this.loggerService.logDebug('storing to storage, getting the roles');\n        this.oidcSecurityCommon.accessToken = access_token;\n        this.oidcSecurityCommon.idToken = id_token;\n        this.setIsAuthorized(true);\n        this.oidcSecurityCommon.isAuthorized = true;\n    }\n\n    private createAuthorizeUrl(\n        isCodeFlow: boolean,\n        code_challenge: string,\n        redirect_url: string,\n        nonce: string,\n        state: string,\n        authorization_endpoint: string,\n        prompt?: string\n    ): string {\n        const urlParts = authorization_endpoint.split('?');\n        const authorizationUrl = urlParts[0];\n        let params = new HttpParams({\n            fromString: urlParts[1],\n            encoder: new UriEncoder(),\n        });\n        params = params.set('client_id', this.configurationProvider.openIDConfiguration.client_id);\n        params = params.append('redirect_uri', redirect_url);\n        params = params.append('response_type', this.configurationProvider.openIDConfiguration.response_type);\n        params = params.append('scope', this.configurationProvider.openIDConfiguration.scope);\n        params = params.append('nonce', nonce);\n        params = params.append('state', state);\n\n        if (isCodeFlow) {\n            params = params.append('code_challenge', code_challenge);\n            params = params.append('code_challenge_method', 'S256');\n        }\n\n        if (prompt) {\n            params = params.append('prompt', prompt);\n        }\n\n        if (this.configurationProvider.openIDConfiguration.hd_param) {\n            params = params.append('hd', this.configurationProvider.openIDConfiguration.hd_param);\n        }\n\n        const customParams = Object.assign({}, this.oidcSecurityCommon.customRequestParams);\n\n        Object.keys(customParams).forEach(key => {\n            params = params.append(key, customParams[key].toString());\n        });\n\n        return `${authorizationUrl}?${params}`;\n    }\n\n    private createEndSessionUrl(end_session_endpoint: string, id_token_hint: string) {\n        const urlParts = end_session_endpoint.split('?');\n\n        const authorizationEndsessionUrl = urlParts[0];\n\n        let params = new HttpParams({\n            fromString: urlParts[1],\n            encoder: new UriEncoder(),\n        });\n        params = params.set('id_token_hint', id_token_hint);\n        params = params.append('post_logout_redirect_uri', this.configurationProvider.openIDConfiguration.post_logout_redirect_uri);\n\n        return `${authorizationEndsessionUrl}?${params}`;\n    }\n\n    private getSigningKeys(): Observable<JwtKeys> {\n        if (this.configurationProvider.wellKnownEndpoints) {\n            this.loggerService.logDebug('jwks_uri: ' + this.configurationProvider.wellKnownEndpoints.jwks_uri);\n\n            return this.oidcDataService\n                .get<JwtKeys>(this.configurationProvider.wellKnownEndpoints.jwks_uri || '')\n                .pipe(catchError(this.handleErrorGetSigningKeys));\n        } else {\n            this.loggerService.logWarning('getSigningKeys: authWellKnownEndpoints is undefined');\n        }\n\n        return this.oidcDataService.get<JwtKeys>('undefined').pipe(catchError(this.handleErrorGetSigningKeys));\n    }\n\n    private handleErrorGetSigningKeys(error: Response | any) {\n        let errMsg: string;\n        if (error instanceof Response) {\n            const body = error.json() || {};\n            const err = JSON.stringify(body);\n            errMsg = `${error.status} - ${error.statusText || ''} ${err}`;\n        } else {\n            errMsg = error.message ? error.message : error.toString();\n        }\n        console.error(errMsg);\n        return observableThrowError(errMsg);\n    }\n\n    private runTokenValidation() {\n        if (this.runTokenValidationRunning || !this.configurationProvider.openIDConfiguration.silent_renew) {\n            return;\n        }\n        this.runTokenValidationRunning = true;\n        this.loggerService.logDebug('runTokenValidation silent-renew running');\n\n        /**\n            First time: delay 10 seconds to call silentRenewHeartBeatCheck\n            Afterwards: Run this check in a 5 second interval only AFTER the previous operation ends.\n         */\n        const silentRenewHeartBeatCheck = () => {\n            this.loggerService.logDebug(\n                'silentRenewHeartBeatCheck\\r\\n' +\n                    `\\tsilentRenewRunning: ${this.oidcSecurityCommon.silentRenewRunning === 'running'}\\r\\n` +\n                    `\\tidToken: ${!!this.getIdToken()}\\r\\n` +\n                    `\\t_userData.value: ${!!this._userData.value}`\n            );\n            if (this._userData.value && this.oidcSecurityCommon.silentRenewRunning !== 'running' && this.getIdToken()) {\n                if (\n                    this.oidcSecurityValidation.isTokenExpired(\n                        this.oidcSecurityCommon.idToken,\n                        this.configurationProvider.openIDConfiguration.silent_renew_offset_in_seconds\n                    )\n                ) {\n                    this.loggerService.logDebug('IsAuthorized: id_token isTokenExpired, start silent renew if active');\n\n                    if (this.configurationProvider.openIDConfiguration.silent_renew) {\n                        this.refreshSession().subscribe(\n                            () => {\n                                this._scheduledHeartBeat = setTimeout(silentRenewHeartBeatCheck, 3000);\n                            },\n                            (err: any) => {\n                                this.loggerService.logError('Error: ' + err);\n                                this._scheduledHeartBeat = setTimeout(silentRenewHeartBeatCheck, 3000);\n                            }\n                        );\n                        /* In this situation, we schedule a heatbeat check only when silentRenew is finished.\n                        We don't want to schedule another check so we have to return here */\n                        return;\n                    } else {\n                        this.resetAuthorizationData(false);\n                    }\n                }\n            }\n\n            /* Delay 3 seconds and do the next check */\n            this._scheduledHeartBeat = setTimeout(silentRenewHeartBeatCheck, 3000);\n        };\n\n        this.zone.runOutsideAngular(() => {\n            /* Initial heartbeat check */\n            this._scheduledHeartBeat = setTimeout(silentRenewHeartBeatCheck, 10000);\n        });\n    }\n\n    private silentRenewEventHandler(e: CustomEvent) {\n        this.loggerService.logDebug('silentRenewEventHandler');\n\n        if (this.configurationProvider.openIDConfiguration.response_type === 'code') {\n            const urlParts = e.detail.toString().split('?');\n            const params = new HttpParams({\n                fromString: urlParts[1],\n            });\n            const code = params.get('code');\n            const state = params.get('state');\n            const session_state = params.get('session_state');\n            const error = params.get('error');\n            if (code && state) {\n                this.requestTokensWithCodeProcedure(code, state, session_state);\n            }\n            if (error) {\n                this._onAuthorizationResult.next(new AuthorizationResult(AuthorizationState.unauthorized, ValidationResult.LoginRequired));\n                this.resetAuthorizationData(false);\n                this.oidcSecurityCommon.authNonce = '';\n                this.loggerService.logDebug(e.detail.toString());\n            }\n        } else {\n            // ImplicitFlow\n            this.authorizedImplicitFlowCallback(e.detail);\n        }\n    }\n}\n","import { ModuleWithProviders, NgModule } from '@angular/core';\nimport { OidcDataService } from '../data-services/oidc-data.service';\nimport { IFrameService } from '../services/existing-iframe.service';\nimport { EqualityHelperService } from '../services/oidc-equality-helper.service';\nimport { StateValidationService } from '../services/oidc-security-state-validation.service';\nimport { TokenHelperService } from '../services/oidc-token-helper.service';\nimport { LoggerService } from '../services/oidc.logger.service';\nimport { OidcSecurityCheckSession } from '../services/oidc.security.check-session';\nimport { OidcSecurityCommon } from '../services/oidc.security.common';\nimport { OidcConfigService } from '../services/oidc.security.config.service';\nimport { OidcSecurityService } from '../services/oidc.security.service';\nimport { OidcSecuritySilentRenew } from '../services/oidc.security.silent-renew';\nimport { BrowserStorage, OidcSecurityStorage } from '../services/oidc.security.storage';\nimport { OidcSecurityUserService } from '../services/oidc.security.user-service';\nimport { OidcSecurityValidation } from '../services/oidc.security.validation';\n\n@NgModule()\nexport class AuthModule {\n    static forRoot(token: Token = {}): ModuleWithProviders {\n        return {\n            ngModule: AuthModule,\n            providers: [\n                OidcConfigService,\n                OidcSecurityService,\n                OidcSecurityValidation,\n                OidcSecurityCheckSession,\n                OidcSecuritySilentRenew,\n                OidcSecurityUserService,\n                OidcSecurityCommon,\n                TokenHelperService,\n                LoggerService,\n                IFrameService,\n                EqualityHelperService,\n                OidcDataService,\n                StateValidationService,\n                {\n                    provide: OidcSecurityStorage,\n                    useClass: token.storage || BrowserStorage,\n                },\n            ],\n        };\n    }\n}\n\nexport interface Type<T> extends Function {\n    new (...args: any[]): T;\n}\n\nexport interface Token {\n    storage?: Type<any>;\n}\n"]}